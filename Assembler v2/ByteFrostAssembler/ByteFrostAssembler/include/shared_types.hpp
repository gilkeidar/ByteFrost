#pragma once
#include <string>
#include <vector>
#include "constants.hpp"
//	Shared types used across the assembler code

//	Forward declaration of AssemblyInstruction struct
struct AssemblyInstruction;

//	Forward declaration of Preprocessor Directive struct
struct Directive;

/**
 * @brief Struct containing property-value pairs of properties that affect the
 * behavior of the Assembler and which can be set externally (i.e., from
 * command-line arguments, from preprocessor directives, and perhaps in future
 * from an external config file).
 */
struct Config {
	//	Property-value pairs, grouped by the earliest entity that can set them
	//	(i.e., properties whose values can be set with command-line arguments
	//		and those that cannot be set with command-line arguments)

	//	==	Command-Line Argument-Settable Properties	==

	/**
	 * @brief File name of the input .asm file (filled by CLAP).
	 */
	std::string input_file_name = UNSET_FILE_NAME;

	/**
	 * @brief File name of the output file (filled by CLAP if "-o" flag is set)
	 */
	std::string output_file_name = UNSET_FILE_NAME;

	/**
	 * @brief Whether the assembled output file should be a binary (.bin) file
	 */
	bool generateBinaryFile = false;

	//	==	Other Properties

	/**
	 * @brief Start address of program (i.e., where the program should be
	 * stored / loaded into in the ByteFrost memory address space)
	 */
	uint16_t start_address = 0x0000;
};

/**
 * @brief Parser-recognized Token types; a Token's token string is mapped to
 * one of these Token types by the Parser.
 */
enum class TokenType {
	INSTRUCTION, GREGISTER, OUT_PRINT_TYPE, TEXT, SREGISTER, NUMBER, IMMEDIATE,
	DIRECTIVE, LABEL, BYTE_CONSTANT, BYTE_LABEL, INVALID
};

/**
 * @brief Struct containing a token string and its identified TokenType.
 */
struct Token {
	/**
	 * @brief The TokenType of this Token.
	 */
	TokenType type;

	/**
	 * @brief The (non-empty) token string of this Token. Token strings contain
	 * no delimiters (as defined by the Parser's delimiter set).
	 */
	std::string token_string;
};

/**
 * @brief Returns a string representation of the given TokenType.
 * @param t TokenType to represent as a string
 * @return std::string representation of the given Tokentype.
 */
std::string TokenTypeToString(TokenType t);

/**
 * @brief Returns a string representation of the given Token.
 * @param t Token to represent as a string
 * @return std::string representation of the given Token.
 */
std::string TokenToString(Token t);

/**
 * @brief Parser-recognized Line types; while parsing a line string from an
 * input .asm file, the Parser converts the line string into a vector of
 * Tokens, and that vector is then mapped by the Parser to a LineType when
 * generating that line string's corresponding Line struct.
 */
enum class LineType { INSTRUCTION, DIRECTIVE, LABEL_DEFINITION, EMPTY, INVALID };

/**
 * @brief A struct that contains all the information about a line string in the
 * input .asm file by the ByteFrost Assembler in order to generate an assembled
 * file.
 */
struct Line {
	/**
	 * @brief Line number (1-indexed)
	 * @note This quantity is 1-indexed, so the first Line is line 1, not line
	 * 0.
	 */
	unsigned int number;

	/**
	 * @brief The LineType of this Line.
	 */
	LineType type;

	/**
	 * @brief The original line string of this Line object as it appeared in
	 * the input .asm file.
	 */
	std::string original_string;

	/**
	 * @brief The vector of Tokens generated by the Parser from the original
	 * line string in the input .asm file.
	 */
	std::vector<Token> tokens;

	/**
	 * @brief This is the memory address of this line in memory.
	 * @note This address assumes that the address of the first instruction is
	 * 0, and so may not represent the true address until the preprocessor
	 * alters it if needed (if a preprocessor directive was specified to shift
	 * the starting address forward, e.g. for RAM programs).
	 * @note This is an 16-bit ADDRESS, NOT a PC value! The PC value of this
	 * address is the address logically shifted right by 1.
	 */
	uint16_t line_address;

	/**
	 * @brief Line constructor.
	 * @param number This line's 1-indexed number in the input .asm file.
	 * @param type This line's LineType.
	 * @param original_string The original string from the input .asm file to
	 * which this Line object corresponds.
	 * @param tokens Vector of Tokens generated when parsing the 
	 * original_string.
	 * @param line_address Memory address of this line as it would be when its
	 * assembled equivalent would be stored in memory during ByteFrost
	 * execution (if this Line is not stored as part of the assembled binary,
	 * then its memory address would be the memory address of the next 
	 * InstructionLine).
	 */
	Line(unsigned int number, LineType type, std::string original_string, std::vector<Token> tokens,
		uint16_t line_address)
		: number(number), type(type), original_string(original_string), tokens(tokens),
		line_address(line_address) {}
};

/**
 * @brief Returns a string representation of the given LineType.
 * @param t LineType to represent as a string
 * @return std::string representation of the given LineType.
 */
std::string LineTypeToString(LineType t);

/**
 * @brief Returns a string representation of the Line pointed to by the given
 * Line pointer.
 * @param line Line pointer of Line to represent as a string
 * @return std::representation of Line pointed to by the given Line pointer.
 */
std::string LineToString(Line* line);

/**
 * @brief A struct of a Line that contains a ByteFrost Assembly instruction;
 * inherits from Line.
 */
struct InstructionLine : Line {
	//	Assembly Instruction of given Line

	/**
	 * @brief AssemblyInstruction of this InstructionLine.
	 */
	AssemblyInstruction* instruction;

	InstructionLine(unsigned int number, std::string original_string, std::vector<Token> tokens,
		uint16_t line_address, AssemblyInstruction* instruction)
		: Line(number, LineType::INSTRUCTION, original_string, tokens, line_address),
		instruction(instruction) {}
};

/**
 * @brief A struct of a Line that contains a Preprocessor directive; inherits
 * from Line.
 */
struct DirectiveLine : Line {
	//	Directive of given line

	/**
	 * @brief Preprocessor directive of this DirectiveLine.
	 */
	Directive* directive;

	DirectiveLine(unsigned int number, std::string original_string, std::vector<Token> tokens,
		uint16_t line_address, Directive* directive)
		: Line(number, LineType::DIRECTIVE, original_string, tokens, line_address),
		directive(directive) {}
};