#pragma once
#include <string>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include "clap.hpp"
#include "shared_types.hpp"
#include "assembly_instructions.hpp"
#include "preprocessor.hpp"

/**
 * @brief Parser class that opens an input .asm file and parses its contents
 * into a std::vector<Line *> lines vector, which is used by subsequent
 * pipeline stages.
 */
class Parser {
public:
	/**
	 * @brief Parser constructor. Initializes Parser's delimiter character set.
	 */
	Parser(Config & config);

	/**
	 * @brief Runs the Parser on the given input .asm file as specified in the
	 * given CommandLineArguments object.
	 * @param lines Reference to the Assembler's empty std::vector<Line *>
	 * lines vector
	 * @param arguments Reference to the Assembler's CommandLineArguments
	 * object (generated by the CLAP)
	 * @param Reference to the Asssembler's instructions string -> 
	 * vector<AssemblyInstruction> instructions hashmap
	 * @param Reference to the Assembler's directives string -> Directive
	 * directives hashmap
	 */
	void run(std::vector<Line *> & lines, 
		std::unordered_map<std::string, 
		std::vector<AssemblyInstruction>> & instructions,
		std::unordered_map<std::string, Directive> & directives);
private:
	/**
	 * @brief Reference to the Assembler's Config instance.
	 */
	Config& config;

	/**
	 * @brief Parser's set of delimiter characters. These are used to separate
	 * token strings in the input .asm file. Consequently, token strings
	 * contain no characters in this set.
	 */
	std::unordered_set<char> delimiters;

	/**
	 * @brief Given a token string w, this method maps the token string to a
	 * TokenType and returns a Token containing the given token string and its
	 * identified TokenType.
	 * @param w string to convert to a Token
	 * @param instructions Reference to the Assembler's string -> 
	 * vector<AssemblyInstruction> instructions hashmap
	 * @return Token matching the given token string w.
	 */
	Token stringToToken(std::string w, 
		std::unordered_map<std::string, std::vector<AssemblyInstruction>> & instructions);

	/**
	 * @brief Generates a Line (or a derived class) object containing the
	 * semantics of the given line string.
	 * @param line_number The 1-indexed line number of the current line string.
	 * @param s The original line string as it appears in the .asm file.
	 * @param tokens tokens vector corresponding to the original line string.
	 * @param instructions Reference to the Assembler's string ->
	 * vector<AssemblyInstruction> instructions hashmap
	 * @param directives Reference to the Assembler's string -> Directive
	 * directives hashmap
	 * @param current_address The ByteFrost memory address of this line
	 * @return Pointer to the generated Line (or derived class) object.
	 */
	Line* generateLine(unsigned int line_number,
		std::string s, 
		std::vector<Token> tokens,
		std::unordered_map<std::string, std::vector<AssemblyInstruction>> & instructions, 
		std::unordered_map<std::string, Directive> & directives,
		uint16_t & current_address);

	/**
	 * @brief Given a vector of Tokens and an AssemblyInstruction, this method
	 * verifies that the first token represents a ByteFrost Assembly
	 * instruction and that the rest of the tokens can be understood as valid
	 * arguments of the given AssemblyInstruction.
	 * @param tokens vector of Tokens
	 * @param instruction Reference to an AssemblyInstruction
	 * @return true if the first token in the tokens vector represents an 
	 * instruction and if the rest are valid arguments for the given 
	 * AssemblyInstruction and false otherwise.
	 */
	bool matchesInstructionArgs(std::vector<Token> tokens, AssemblyInstruction & instruction);

	/**
	 * @brief Determines whether the given tokens vector can represent a valid
	 * preprocessor directive line, i.e. that the first token represents a
	 * preprocessor directive invocation and that the rest of the tokesn are
	 * valid arguments of that preprocessor directive.
	 * @param tokens vector of Tokens
	 * @param directive Reference to a Directive
	 * @return true if the first token in the tokens vector represents a
	 * preprocessor directive and if therest are valid arguments for the given
	 * Directive and false otherwise.
	 */
	bool matchesDirectiveArgs(std::vector<Token> tokens, Directive& directive);


	/**
	 * @brief Computes the 16-bit ByteFrost address of the next Line based on
	 * the size of the AssemblyInstruction on the current line.
	 * @param current_address ByteFrost memory address of current Line
	 * @param instruction AssemblyInstruction on the current Line.
	 * @return 16-bit ByteFrost address of the next Line.
	 */
	uint16_t getNextLineAddress(uint16_t current_address, AssemblyInstruction & instruction);
};