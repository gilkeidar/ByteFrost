#include "preprocessor.hpp"
#include "utility.hpp"
#include <iostream>
#include <unordered_set>

Preprocessor::Preprocessor() {

}

void Preprocessor::run(std::vector<Line*>& lines, CommandLineArguments& args) {
	std::cout << "=== Stage 2: Preprocessor.run() ===" << std::endl;
	
	//	Iterate through eaach Line in the lines vector generated by the Parser.
	for (Line* line : lines) {
		switch (line->type) {
			case LineType::DIRECTIVE: {
				//	Case 1: Line is a DirectiveLine.
				//	Handle the directive in the directive line.
				DirectiveLine* directive_line = (DirectiveLine*)line;
				this->handleDirective(directive_line);
				break;
			}
			case LineType::INSTRUCTION: {
				//	Case 2: Line is an InstructionLine.
				//	Iterate through the line's vector of Tokens.
				//	If a Token has type TokenType::TEXT or 
				//	TokenType::BYTE_CONSTANT, then attempt to find a 
				//	PreprocessorConstant with that name.
				//	If such a constant is found, replace the token's value with
				//	the constant's value and replace the token's type with 
				//	TokenType::IMMEDIATE.
				//	If such a constant is not found, throw an error (undefined 
				//	constant)

				//	TokenTypes that may contain a Preprocessor constant
				std::unordered_set<TokenType> constant_types({
						TokenType::BYTE_CONSTANT,
						TokenType::TEXT
					});
				
				for (Token& token : line->tokens) {
					//	Skip this token if it's not a BYTE_CONSTANT or TEXT
					if (constant_types.find(token.type) == constant_types.end())
						continue;

					long immediate_value;
					if (token.type == TokenType::BYTE_CONSTANT) {
						//	1.	From the token value string, get the constant
						//		name and the BYTE_SELECT string.
						std::string constantName = getConstantNameFromByteConstant(token.token_string);
						int constantIndex = getConstantIndexFromByteConstant(token.token_string);

						//	2.	Attempt to find constant in Preprocessor's
						//		constants hashmap
						if (constants.find(constantName) == constants.end()) {
							//	Constant not found - throw an error
							throwErrorLine(line->number, "Undefined constant '"
								+ constantName + "'.");
						}

						PreprocessorConstant & constant = constants[constantName];

						//	3.	Ensure that the index used can fit in the
						//		constant's defined size and that the index is
						//		not negative.
						if (constantIndex < 0 || constantIndex >= constant.size) {
							throwErrorLine(line->number, "Index "
								+ std::to_string(constantIndex)
								+ " is out of bounds for constant '" + constant.name
								+ "' that is of size "
								+ std::to_string(constant.size) + " bytes.");
						}

						//	4.	Get immediate value from Constant and index
						immediate_value = getByteFromInt(constant.value, constantIndex);
					}
					else if (token.type == TokenType::TEXT) {
						//	1.	Attempt to find constant in Preprocessor's
						//		constants hashmap
						if (constants.find(token.token_string) == constants.end()) {
							//	Constant not found - throw an error
							throwErrorLine(line->number, "Undefined constant '"
								+ token.token_string + "'.");
						}

						PreprocessorConstant & constant = constants[token.token_string];

						//	2.	Get immediate value from found 
						//		PreprocessorConstant
						immediate_value = constant.value;
					}

					//	Replace token type with TokenType::IMMEDIATE and value
					//	with immediate string
					token.type = TokenType::IMMEDIATE;
					token.token_string = generateImmediateString(immediate_value);
				}
			}
		}
	}
}

void Preprocessor::handleDirective(DirectiveLine* line) {
	std::cout << "handleDirective()" << std::endl;

	switch (line->directive->type) {
		case DirectiveType::define:
			this->handleDefineDirective(line);
			break;
		default:
			throwError("default case encountered");
	}
}

//	Directive handlers
void Preprocessor::handleDefineDirective(DirectiveLine* line) {
	std::cout << "handleDefineDirective()" << std::endl;

	//	Get DefineDirective arguments.
	//	Tokens: .define CONST_SIZE CONST_NAME CONST_VALUE

	long long constSize = getNumberValue(line->tokens[1].token_string);

	if (constSize < 0) {
		throwErrorLine(line->number, "A constant may not be declared with a negative size.");
	}

	PreprocessorConstant constant {
		line->tokens[2].token_string,
		(size_t) constSize,
		getNumberValue(line->tokens[3].token_string)
	};

	//	If a constant with the given name already exists, throw an error
	if (this->constants.find(constant.name) != this->constants.end()) {
		throwErrorLine(line->number, "Duplicate definition of constant '" +
			constant.name + "'.");
	}

	//	If the constant size is larger than the maximum size of a preprocessor
	//	constant, throw an error
	if (constant.size > PREPROCESSOR_CONSTANT_MAX_SIZE) {
		throwErrorLine(line->number, 
			"A constant may not be declared with size larger than "
			+ std::to_string(PREPROCESSOR_CONSTANT_MAX_SIZE) + " bytes.");
	}

	std::cout << "DEFINED CONSTANT " << constant.name << " WITH VALUE " << std::hex << constant.value << "!" << std::endl;

	//	Add constant to constants hashmap
	this->constants[constant.name] = constant;
}