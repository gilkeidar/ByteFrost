#   Stage 2 - Preprocessor

This is the third stage of the ByteFrost Assembler pipeline.

The **Preprocessor** takes as input the `std::vector<Line *>` vector generated 
by the `Parser`. It then does two things:
1.  Handle every `Line` that is a `Directive` statement by updating its or the
    `Assembler`'s state.
2.  Replace every `TokenType::TEXT` token in `InstructionLine`s with 
a `TokenType::IMMEDIATE` token (as these were assumed by the `Parser` to be 
preprocessor constants defined in `.define` `Directive` `Line`s; the 
preprocessor therefore attempts to replace these with immediate tokens that 
contain the constant's defined value.)

##  Definitions

### The `Preprocessor` Class

The `Preprocessor` is defined as the following class:

```cpp
class Preprocessor {
public:
    Preprocessor();
    void run(std::vector<Line *> & lines, CommandLineArguments & args);
private:
    //  Hashmap of string -> PreprocessorConstant
    unordered_map<string, PreprocessorConstant> constants;

    void handleDirective(DirectiveLine * line);

    //  Directive handlers
    void handleDefineDirective(DirectiveLine * line);
    void handleStartDirective(DirectiveLine * line);
    //  ...
}
```

### `DirectiveType`

Each directive that the Preprocessor recognizes has its own `DirectiveType` enum
value:

```cpp
enum class DirectiveType {define, start, ram, rom, ...};
```

### `Directive`s

Each `Preprocessor` directive is encoded as a `Directive` struct in the
following way:

```cpp
struct Directive {
    string name;
    DirectiveType type;
    vector<TokenType> expected_param_types;
}
```

The `preprocessor.hpp` file contains a const array of all Preprocessor 
`Directive`s.

The `Assembler` has a string -> Directive * hashmap 
`std::unordered_map<string, Directive *> directives` that is passed to the
`Parser` (like the `instructions` hashmap) in order for it to generate
`DirectiveLine`s, defined below.

### `DirectiveLine`

The `DirectiveLine` is a struct that derives from `Line`:

```cpp
struct DirectiveLine : Line {
    Directive * directive;
}
```

See the Parser's definition of `DirectiveLine` for more details on how the
`Parser` generates a `DirectiveLine`.

##  Running the `Preprocessor`

The `Preprocessor.run()` method implements the following loop:

```cpp
for (Line * line : lines) {
    //  Iterate through each line in the vector<Line *> lines generated by the
    //  Parser. The current line is line.
    //  Case 1: line is a DirectiveLine.
    //      Handle the directive in the DirectiveLine.
    //  Case 2: line is an InstructionLine.
    //      Iterate through the line's Token vector.
    //          If a Token in the Token vector has type TokenType::TEXT or
    //          TokenType::BYTE_CONSTANT then attempt to find a Preprocessor
    //          constant (defined with a .define Preprocessor Directive) with
    //          that name.
    //              If such a constant was found, replace the token's value with
    //              an immediate string that contains the constant's value and
    //              replace the token's type with TokenType::IMMEDIATE.
    //              If not, throw an error (undefined constant).
    switch (line.type) {
        case LineType::DirectiveLine: {
            DirectiveLine * directive_line = (DirectiveLine *)line;
            handleDirective(directive_line);
            break;
        }
        case LineType::InstructionLine: {
            for (Token & token : line.tokens) {
                //  Skip this token if it's not a BYTE_CONSTANT or TEXT
                if (token.type != TokenType::BYTE_CONSTANT &&
                    token.type != TokenType::TEXT)
                    continue;
                int immediate_value;
                if (token.type == TokenType::BYTE_CONSTANT) {
                    //  1.  From the token value string, get the constant name
                    //      and the BYTE_SELECT string
                    string constantName = getConstantStringFromByteConstant(token.value);
                    size_t constantIndex = getConstantIndexFromByteConstant(token.value);
                    //  2.  Attempt to find constant in Preprocessor's
                    //      string -> PreprocessorConstant hashmap
                    if (constants.find(constantName) == constants.end()) {
                        //  Constant not found - throw an error
                        throwError("Undefined constant " + constantName + ".");
                    }
                    PreprocessorConstant * constant = constants[constantName];
                    //  3.  Ensure that the index used can fit in the constant's
                    //      defined size
                    if (constantIndex >= constant.size) {
                        throwError("Index out of bounds error");
                    }
                    //  4.  Get immediate value from Constant and index
                    immediate_value = getByteFromInt(constant.value, constantIndex);
                }
                else if (token.type == TokenType::TEXT) {
                    //  1.  Attempt to find constant in Preprocessor's string
                    //      -> PreprocessorConstant hashmap
                    if (constants.find(token.value) == constants.end()) {
                        //  Constant not found - throw an error
                        throwError("Undefined constant " + constantName + ".");
                    }
                    //  Get immediate value from Constant
                    immediate_value = Constant.value;
                }

                //  Replace token type with TokenType::IMMEDIATE and value with
                //  immediate string
                token.type = TokenType::IMMEDIATE;
                token.value = generateImmediateString(immediate_value);
            }
        }
    }
}
```

The `handleDirective(DirectiveLine * line)` implements the following switch
case:

```cpp
void handleDirective(DirectiveLine * line) {
    switch (line->directive.type) {
        case DirectiveType::define:
            handleDefineDirective(DirectiveLine * line);
            break;
        case DirectiveType::start:
            handleStartDirective(DirectiveLine * line);
            break;
        //  ...
    }
}
```