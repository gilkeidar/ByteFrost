#   Assembler `Config` Object Proposal v2

May 14, 2025

**Proposal Summary:** Add a `Config` class that contains configuration
properties that affect the `Assembler`'s behavior to the `Assembler`. This will
in effect be a generalization of the `CommandLineArguments` object generated by
the CLAP (and a replacement of it).

The main idea here is the following:

Some behaviors of the `Assembler` should be configurable or require certain
argument information (e.g., the input file name, the output file name, the
output file type (`.bin` or `.mlg`), the start address, etc.), and the pipeline
stage (or other source) from which the value of the property is learned is not
necessarily the same as the pipeline stage that needs to know the value of the
property to affect its execution.

We can consider each configuration field of the proposed `Config` class to be
either a *property* (i.e., a data value that affects the behavior of the
`Assembler` in some way) or as a *behavior* (i.e., a method that can be chosen
(like a function pointer) by some pipeline stage). However, I think that we can
simplify matters and only use *properties* (i.e., the `Config` class won't need
to contain function pointers). A property could be created whose values can be
mapped to different behaviors (e.g., a property *functionToUse* could have
values *A*, *B*, and *C* which are mapped using a hashmap / other function to
functions `func1()`, `func2()`, and `func3()`, respectively).

The property values of the `Config` class can be construed as
`(property, value)` tuples and can be set in four ways:
1.  Default Values (Hardcoded)
    *   These `(property, value)` tuples are hardcoded in the ByteFrost 
        Assembler source code as part of the `Config` class' default 
        constructor.
    *   Every property must have a default value.
2.  External Config File
    *   `(property, value)` tuples are read from an external config file.
    *   Not all properties need to be specified; unspecified properties would
        use their default values.
3.  Command-Line Arguments
    *   Command line arguments are mapped to `(property, value)` tuples. This
        is done using each `CLFlag`'s `is_set` field and argument values.
4.  Preprocessor Directives
    *   Some preprocessor directives can be mapped to `(property, value)`
        tuples.

`(property, value)` tuples are set in the following order; the value of a
`(property, value)` pair is the last set value.

1.  Default Values
2.  Command-Line Arguments (found by the CLAP)
3.  (Not yet implemented) External Config File
    *   After command-line arguments since a different config file name may be
        specified by a command-line argument flag
4.  Preprocessor Directives (found by the Preprocessor)
    *   Preprocessor runs immediately after the Parser, so preprocessor
        directives should only be used to set `Config` properties used by the
        Preprocessor or later stages

**Note:** Important to avoid using an intermediate value that could be
    subsequently changed to avoid inconsistent behavior. Hence, when using a
    `(property, value)` pair, it must be the case that the property's value is
    "solidified" (won't be changed again). 
*   One way to do this is to store each property in the `Config` as a
    `(property, value, finalized)` tuple; the default values are
    `(property, defaultValue, false)` and when set by some other source, then
    the `finalized` field is set to `true` if it should have the last word.
    When the property's value needs to be read, we can check whether `finalized`
    is set... but this causes problems since default values are never finalized.
*   **Different approach:** For each property, we can know by context which 
    entity(s) / pipeline stage(s) need to read the property's value, and based
    on that decide in which property value source(s) can set it.

This can also be used in effect to implement message passing between stages; for
instance:

Consider the problem of specifying a start address to the assembler. Currently,
the assembler assumes that the first instruction in an assembly file will be
stored in memory at address `0x0000`, so all label addresses are calculated
based on this assumption. This only works when the assembly file is of a program
that is intended to be stored and run in the ROM; if a program should be loaded
into RAM, at, say, address `0x3000`, then using this approach, all branches in
the program will break when loading the program to address `0x3000`.

Hence, the assembler should be notified that it should offset all label
addresses forward by `0x3000` (or in other words, that the start address is
`0x3000`). This can be done using the sources mentioned above (config file,
command-line argument, and / or introducing a new preprocessor directive such
as `.start 0x3000`).

We may now begin to see the problem mentioned above: the pipeline stage in the
assembler that learns of the change in default behavior (new value for a
particular `Config` property) (the CLAP / Preprocessor in this example, but
could also be an external config file) is not the same stage that *uses* the new
behavior (in this case, the Label Handler (which runs after the Preprocessor)).

##  Implementation

The implementation of the `Config` class would involve the following:

In `shared_types.hpp`: (define `Config` struct)

```c++
//  ...
struct Config {
    //  Config (property, value) pairs grouped by earliest pipeline stage that 
    //  needs to use them

    //  == CLAP ==

    //  == External Config File (not yet implemented) ==
    std::string config_file_name = "assembler.config";

    //  == Parser ==

    //  Input file name
    std::optional<std::string> input_file_name;

    //  == Preprocessor ==

    //  == Label Handler ==
    uint16_t start_address = 0x0000;

    //  == Code Generation ==

    //  Maybe replace with "outputFileType" enum
    bool generateBinaryFile = false;

    std::optional<std::string> output_file_name;
}
```