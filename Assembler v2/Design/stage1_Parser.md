#   Stage 1 - Parser

This is the second stage of the ByteFrost Assembler pipeline.
The **Parser** takes as input the `CommandLineArguments` object pointer
generated by the `CLAP` and returns a `std::vector<Line *>` vector that contains
a `Line *` to a `Line` object for each line in the input `.asm` file (assuming 
this file exists).

##  Definitions

### Delimiter Set `delimiters`

The delimiter set is an `std::unordered_set<char>` stored by the `Parser` class
that contains all characters that are understood to be delimiters in a line and
which should be used as separators between token strings. The delimiter set
`std::unordered_set<char> delimiters` is an implementation of the following set:

$DELIMITERS = \{\texttt{SPACE}, \texttt{TAB}, \texttt{,}\}$

### `Token`s

A `Token` is a struct containing a `TokenType` enum and a token string:

```cpp
struct Token {
    TokenType type;
    string token_string;
}
```

The Parser recognizes the following `Token` types, which are the values of the
`TokenType` enum:

```cpp
enum TokenType = {INSTRUCTION, GREGISTER, TEXT, SREGISTER, NUMBER, IMMEDIATE,
DIRECTIVE, LABEL, BYTE_CONSTANT, BYTE_LABEL, INVALID};
```
####    `INSTRUCTION`

A token string `w` is mapped to `TokenType::INSTRUCTION` if
1. `w` $\in TEXT$.
2. `w` $\in INSTRUCTIONS$.
    * This is checked by seeing whether `w` is a key of the
        `std::unordered_set<std::string, std::vector<AssemblyInstruction>> instructions` hashmap in the `Assembler` class.

####    `GREGISTER`

A token string `w` is mapped to `TokenType::GREGISTER` if
1. `w` $\in TEXT$.
2. `w` $\in GREGISTER$.

####    `TEXT`

A token string `w` is mapped to `TokenType::TEXT` if
1. `w` $\in TEXT$.
2. `w` cannot be mapped to `TokenType::INSTRUCTION` or `TokenType::GREGISTER`.

####    `SREGISTER`

A token string `w` is mapped to `TokenType::SREGISTER` if
1. The length of `w` is `>= 2`.
2. `w[0] = '%'`.
3. `w[1]...w[len(w) - 1]` $\in SREGISTER$.

####    `NUMBER`

A token string `w` is mapped to `TokenType::NUMBER` if
1. `w` $\in NUMBER$.

####    `IMMEDIATE`

A token string `w` is mapped to `TokenType::IMMEDIATE` if 
1. The length of `w` is `>= 2`.
2. `w[0] = '#'`.
3. `w[1]...w[len(w) - 1]` $\in NUMBER$.

####    `DIRECTIVE`

A token string `w` is mapped to `TokenType::DIRECTIVE` if
1. The length of `w` is `>= 2`.
2. `w[0] = '.'`.
3. `w[1]...w[len(w) - 1]` $\in TEXT$.

####    `LABEL`

A token string `w` is mapped to `TokenType::LABEL` if
1. The length of `w` is `>= 2`.
2. `w[0] = ':'`.
3. `w[1]...w[len(w) - 1]` $\in TEXT$.

####    `BYTE_CONSTANT`

A token string `w` is mapped to `TokenType::BYTE_CONSTANT` if
1. There exist string `u` $\in TEXT$ and `v` $\in BYTE\_SELECT$ such that
    `w = uv`.

####    `BYTE_LABEL`

A token string `w` is mapped to `TokenType::BYTE_LABEL` if
1. There exist strings `u` and `v` such that:
    1. `u` can be mapped to `TokenType::LABEL`,
    2. `v` $\in BYTE\_SELECT$, and
    3. `w = uv`

####    `INVALID`

A token string `w` is mapped to `TokenType::INVALID` if
1. `w` cannot be mapped to any `TokenType` that is not `TokenType::INVALID`.

### Quantity Types

Each `AssemblyInstruction` has a `std::vector<TokenType> expected_param_types`
vector that specifies the number and argument types of argument `Token`s that
the instruction expects.

E.g., for the assembly instruction `ADD R1, R2, R3`, the expected parameter 
types are all of type `TokenType::GREGISTER`, so the `expected_param_types` 
vector is `{TokenType::GREGISTER, TokenType::GREGISTER, TokenType::GREGISTER}`.

However, consider the instruction `ADD, R1, #5`. This instruction expects a
general purpose register and then an immediate. Hence its expected parameter
types vector is `{TokenType::GREGISTER, TokenType::IMMEDIATE}`.

Given that immediates can be expressed in multiple ways, specifically as 
immediates (e.g., `#0x5`), labels, (e.g., `:main`), and preprocessor constants 
(e.g., `PI`), we have a bit of a problem as potentially valid invocations such
as `ADD R1, PI` will be marked as a mismatch since `PI` is of type 
`TokenType::TEXT` and not `TokenType::IMMEDIATE`.

~~To avoid this, the Parser has a set of "quantity types" which are defined as
the set `{TokenType::IMMEDIATE, TokenType::LABEL, TokenType::TEXT}`.~~

To avoid this, the Parser has a set of "quantity types" which are defined as the
set `{TokenType::IMMEDIATE, TokenType::BYTE_LABEL, TokenType::TEXT,
TokenType::CONSTANT_LABEL}.`

~~If an argument's `TokenType` is a quantity type and its corresponding expected
argument type is also a quantity type, then the Parser will mark these as
matching even if their `TokenType`s are different. This allows for a single
definition of the instruction `ADD immediate` with the expected parameter types
vector `{TokenType::GREGISTER, TokenType::IMMEDIATE}` without needing to
explicitly specify that `TokenType::TEXT` is also allowed (however, this does
mean that `TokenType::LABEL` will be allowed, which may seem unnatural; but this
can be caught later on by comparing the size of the quantities. E.g., a label
is always a 16-bit quantity as it's an address, and the immediate in
`ADD immediate` is capped at being 4-bits, so the Assembler will throw a warning
that information loss can occur).~~

If an argument's `TokenType` is a quantity type and its corresponding expected
argument type is also a quantity type, then the Parser will mark these as
matching even if their `TokenType`s are different. This allows for a single
definition of the instruction `ADD immediate` with the expected parameter types
vector `{TokenType::GREGISTER, TokenType::IMMEDIATE}` without needing to
explicitly specify that `TokenType::TEXT` is also allowed.
This means that, for `ADD immediate,` the Parser will allow the following
invocations:
*   `ADD R1, #4`        (immediate)
*   `ADD R1, :main[1]`  (label byte (high byte specified))
*   `ADD R1, PI`        (constant (understood by the Parser as TEXT))
*   `ADD R1, PI[5]`     (constant byte (6th byte specified))

But the following invocations are disallowed:
*   `ADD R1, R2`        (second argument cannot be a general register)
*   `ADD R1, :main`     (second argument may not be a label)
*   `ADD R1, LDR`       (second argument may not be another instruction)

This also ensures that an assembly instruction that expects a label will always
get exactly a label, as `TokenType::LABEL` is not a quantity type, e.g.:
`BEQ :label` has the expected parameter types vector `{TokenType::LABEL}`, so
the invocation `BEQ :main` is allowed, but `BEQ #5`, `BEQ :main[0]`, and
`BEQ ADDRESS_CONSTANT` are not allowed.

As branch instructions only use labels, the programmer cannot hardcode branch
addresses. This restriction both promotes good practices (since all branch
addresses are labels, the code is easier to read) and also avoids undue bugs as
the ByteFrost assembler supports assembly instruction derivation, i.e., assembly
instructions *derive* into ISA instructions, and some assembly instructions may
derive into multiple ISA instructions, so the programmer should not rely on
counting instructions to calculate jump sizes.

### `Line`s

A `Line` is a struct that contains all the information needed by the ByteFrost
Assembler about a line in the input `.asm` file to generate an assembled file.

A `Line` object is defined in the following way:

```cpp
struct Line {
    LineType type;
    string original_string;
    vector<Token> tokens;
    //  Maybe add a Union of possible line-related data here, such as
    //      Instruction, Directive, LabelDefinition, Empty
    //  the access format depends on the `LineType` (e.g., access the union as
    //  an Instruction if the LineType is LineType::INSTRUCTION)
    //  Alternatively, can handle this using inheritance from Line
}
```

The Parser recognizes the following `LineType`s:

```cpp
enum LineType = {INSTRUCTION, DIRECTIVE, LABEL_DEFINITION, EMPTY, INVALID};
```

####    `INSTRUCTION`

A `vector<Token> tokens` vector is mapped to `LineType::INSTRUCTION` if
1. `tokens.size() >= 1`
2. `tokens[0].type == TokenType::INSTRUCTION`
3. There exists an instruction that has the name `tokens[0].token_string`.
    * Technically, this is a redundant condition given 4., but it may be simpler
        to check this first
4. For exactly one instruction that has the name `tokens[0].token_string`,
    the tokens in the rest of the `tokens` vector (i.e., 
    `tokens[1]...tokens[tokens.size() - 1]`) match in type the expected token
    arguments of this instruction (and the number of arguments must match as
    well).
    * The Parser can be lenient here, if the expected argument `TokenType` is a
        "quantity type".

The `InstructionLine` struct inherits from `Line` and is defined as follows,
containing a pointer to the `AssemblyInstruction` the `Line` contains.

```cpp
struct InstructionLine : Line {
    AssemblyInstruction * instruction;
}
```

####    `DIRECTIVE`

A `vector<Token> tokens` vector is mapped to `LineType::DIRECTIVE` if
1. `tokens.size() >= 1`
2. `tokens[0].type == TokenType::DIRECTIVE`
3. There exists a preprocessor directive with the name 
    `tokens[0].token_string.substr(1)` (i.e., the directive name doesn't include
    the `.` at the start of the directive token string)
4. Each `Token`'s `TokenType` in `tokens[1]...tokens[tokens.size() - 1]` matches
    with the corresponding `TokenType` in the directive's expected `TokenType`
    list, and the number of tokens (i.e., `tokenss.size() - 1`) must match the
    number of expected token arguments of the directive.

####    `LABEL_DEFINITION`

A `vector<Token> tokens` vector is mapped to `LineType::LABEL_DEFINITION` if
1. `tokens.size() == 1`
2. `tokens[0].type == TokenType::LABEL`

####    `EMPTY`

A `vector<Token> tokens` vector is mapped to `LineType::EMPTY` if
1. `tokens.size() == 0`

####    `INVALID`

A `vector<Token> tokens` vector is mapped to `LineType::INVALID` if
1. `tokens` cannot be mapped to any `LineType` that is not `LineType::INVALID`.

##  Parsing

The Parser generates the `std::vector<Line *>` vector that represents the input
`.asm` file's contents with the following steps:

### 1.  Open the input file.

The Parser will attempt to open the input file for reading. If this step fails,
the Parser will throw an error.

### 2.  Generate a `std::vector<string> line_strings` vector

The Parser will create a `std::vector<string> line_strings` object and add each
line read from the input file to this vector.

### 3.  Generate a `std::vector<Line *> lines` vector

This is the main step of the Parser. To accomplish it, the Parser will do the
following for each line string `s` in the `std::vector<string> line_strings`
vector:

####    1.  Generate a string `s'` that contains no comments.

Given a line string `s`, `s'` is the substring of `s` from index 0 to the index
of the start of the first instance of the comment string `//`. If `s` contains
no comment strings, then `s' = s`.

####    2.  Generate a `std::vector<string> token_strings` vector.

Allocate a `std::vector<string> token_strings` vector.
The Parser iterates through each character in `s'`.
For each character `c` in `s'`:
1. If $c \in DELIMITERS$, then set `isTokenString` to `false`.
2. Otherwise, set `isTokenString` to `true`.
3. If `isTokenString` is `true`: append `c` to `currTokenString`
4. Else if `isTokenString` is `false` and `currTokenString.length() > 0`:
    1. Add `currTokenString` to `token_strings`
    2. Set `currTokenString` to an empty string.

After running through every character in `s'`, if `isTokenString` is still
`true`, then add the current `currTokenString` to the `token_strings` vector.

####    3.  Generate a `std::vector<Token> tokens` vector.

Allocate a `std::vector<Token> tokens` vector.
Iterate through each token string in `token_strings`.
For each token string `w` in `token_strings`:
1. If $w \in TEXT$:
    1. If $w \in INSTRUCTIONS$, then add a token with `TokenType::INSTRUCTION`
        to the `tokens` vector.
    2. Else if $w \in GREGISTERS$, then add a token with `TokenType::GREGISTER`
        to the `tokens` vector.
    3. Else, add a token with `TokenType::TEXT` to the `tokens` vector.
2. etc. (map `w` to a `TokenType` and add a `Token` containing this type and
    `w` to the `tokens` vector.)

If a token string `w` cannot be mapped to a `TokenType`, throw an error (as an
invalid token has been encountered).

####    4. Generate a `Line` object.

1. Allocate a `Line` object.
2. Map the `std::vector<Token> tokens` vector to a `LineType`.
3. Add a pointer to the `Line` object to the `vector<Line *> lines` vector.

### 4. Return the `std::vector<Line> lines` vector

After the `std::vector<Line *> lines` vector has been generated, it is returned 
by the Parser to the `Assembler`.