//	A Simple ls -ls Implementation (!!!) for BFSv1
//	Assumes:
//		1.	The ByteFrost has a connected SD card that has a disk file using the
//			ByteFrost Filesystem Version 1 (BFSv1).
//	In the ByteFrost Filesystem Version 1, the ByteFrost disk has the following
//	properties:
//	*	block size = sector size = 256 bytes
//	+-------------+-------------------+-----------+-----------------+
//	| Block Range | # blocks in range | Size      | Use             |
//  +-------------+-------------------+-----------+-----------------+
//	| 0 - 7       | 8                 | 2 KB      | Boot code       |
//	| 8           | 1                 | 256 bytes | Directory block |
//	| ...         | ...               | ...       | ...             |
//
//	This program does the following:
//	1.	Print "$ ls -ls\n" (pretends it's a shell)
//	2.	Load block 8 (sector 8) that contains the disk root (and only) directory
//		block into RAM at page 0x30 (48)
//	3.	For each directory entry (0 through 15):
//		*	Each directory entry is 16 bytes long and has the following format:
//			[14 byres filename][2 bytes inode block pointer (block ID)]
//		Note:
//			*	The filename can be at most 14 characters long. Hence:
//				1.	If the length of the filename is < 14 characters, it will be
//					terminated with a \0 sentinel (0 byte).
//				2.	If the length of the filename == 14 characters, it will not
//					be terminated with a \0 sentinel.
//			*	Therefore, to read a filename, read from the first byte in the
//				directory entry until either a \0 sentinel is reached OR the max
//				length (14 bytes) has already been reached (requiring adding a
//				\0 sentinel manually for generic string use).
//			*	A direcory entry is INVALID if the inode block pointer is 0.
//				(invalid meaning unused)
//		1.	Read the inode block pointer (last 2 bytes) of the directory entry.
//			1.	If the inode block pointer is 0, skip to the next directory
//				entry.
//		2.	Print the file entry using ls -ls format, specifying:
//			*	-l (use long format)
//			*	-s (print the file size in disk blocks)
//

//	Pseudocode:
//	printf("$ ls -ls\n");
//	1.	Load block 8 (sector 8) that contains the disk root (and only) directory
//		block into RAM at page 0x30 (48).
//	2.	Set total_blocks (a 16-bit counter since there are 2048 total blocks in
//		the disk) to 0.
//	3.	For each directory entry (0 through 15):
//		1.	If the inode block pointer of the current entry is 0, skip to the
//			next entry.
//		2.	Load the inode block of the current entry at page 0x31 + i (where i
//			is the current directory entry index).
//		3.	Increment total_blocks by the file size field in the inode.
//	4.	printf("total %d\n", total_blocks);
//	5.	For each directory entry (0 through 15):
//		*	[block count (2 chars)][space][size in bytes (4 chars)][space][filename 14 chars]
//			(effectively, filenames must be at most 12 chars to fit on screen in
//			one line)
//		1.	If the inode block pointer of the current entry is 0, skip to the
//			next entry.
//		2.	Read the file size field in blocks of this entry's inode and print
//			it.
//		3.	Print space.
//		4.	Read the file size field in bytes of this entry's inode and print it
//			(requires to GPRs).
//		5.	Print space.
//		6.	Print the filename.
//		7.	Print newline.

.start 0x2000

.define	1 NEW_LINE	 	0x10
.define 1 SPACE			0x20
.define	1 _A				0x41
.define	1 _B				0x42
.define	1 _C				0x43
.define	1 _D				0x44
.define	1 _E				0x45
.define	1 _F				0x46
.define	1 _G				0x47
.define	1 _H				0x48
.define	1 _I				0x49
.define	1 _J				0x4a
.define	1 _K				0x4b
.define	1 _L				0x4c
.define	1 _M				0x4d
.define	1 _N				0x4e
.define	1 _O				0x4f
.define	1 _P				0x50
.define	1 _Q				0x51
.define	1 _R				0x52
.define	1 _S				0x53
.define	1 _T				0x54
.define	1 _U				0x55
.define	1 _V				0x56
.define	1 _W				0x57
.define	1 _X				0x58
.define	1 _Y				0x59
.define	1 _Z				0x5a
.define 1 COLON				0x3a
.define 1 LEFT_PAR			0x28
.define	1 RIGHT_PAR			0x29
.define 1 COMMA				0x2c
.define 1 ASTERISK			0x2a
.define 1 _x				0x78
.define 1 EQUALS			0x3d
.define	1 dollar			0x24
.define 1 _l				0x6c
.define 1 _s				0x73
.define 1 _t				0x74
.define 1 _o				0x6f
.define 1 _a				0x61
.define 1 DASH				0x2d

//	Offsets assuming base address is at 0xE000
.define	1 DISK_MMIO_PAGE_OFFSET			0
.define	1 DISK_MMIO_SECTOR_HI_OFFSET	1
.define 1 DISK_MMIO_SECTOR_LO_OFFSET	2
.define 1 DISK_MMIO_GO_OFFSET			3

.define	1 NUM_DIR_ENTRIES		16
.define	1 DIR_ENTRY_SIZE_BYTES	16

.define	1 DirectoryEntry_filename_offset	0
.define 1 DirectoryEntry_inode_block_sector_offset_lo	15
.define 1 DirectoryEntry_inode_block_sector_offset_hi	14

//  Memory use:
//  Page 0x30: Directory block
//  Page 0x31 - 0x46: Inode array
//      *   Directory entry index in directory block is used as index to
//          this array.
//  Stack pointer at 0xDFFF.
//  Stack breakdown:
//  SP:		total_blocks (high)
//	SP - 1:	total_blocks (low)
.define	1 dir_block_page		0x30
.define 1 inode_arr_base_page	0x31
.define	2 sdcard 				0xE000
.define	1 sp_total_blocks_hi	0
.define	1 sp_total_blocks_lo	-1

//  Implementation

//	0.	Set SP to 0xDFFF.
0xbb, 0xdf,	// 0x2000: LDA %SP, H, #0xDF
0x9b, 0xff,	// 0x2002: LDA %SP, L, #0xFF

//	1.	printf("$ ls -ls\n");
0x0d, 0x24,	// 0x2004: OUT dollar, A
0x0d, 0x20,	// 0x2006: OUT SPACE, A
0x0d, 0x6c,	// 0x2008: OUT _l, A
0x0d, 0x73,	// 0x200a: OUT _s, A
0x0d, 0x20,	// 0x200c: OUT SPACE, A
0x0d, 0x2d,	// 0x200e: OUT DASH, A
0x0d, 0x6c,	// 0x2010: OUT _l, A
0x0d, 0x73,	// 0x2012: OUT _s, A
0x0d, 0x10,	// 0x2014: OUT NEW_LINE, A

//	2.	Load block 8 that contains the disk root (and only) directory block into
//		RAM at page 0x30.

//	Disk MMIO interface is as follows:
//	Byte 0 (0xE000): Page (in ByteFrost address space)
//	Byte 1 (0xE001): Command and Sector High (3 lsbs)
//	Byte 2 (0xE002): Sector Low (8 bits)
//	Byte 3 (0xE003): Go (R/W to this address initiates disk operation)
//
//	Bytes 1 and 2 of the interface can be viewed as follows:
//	[Byte 1                           ][Byte 2]
//	15  14  13  12  11  10-8           7-0
//	R/W ?   ?   ?   ?   Sector ID High Sector ID Low
0x7b, 0xe0,	// 0x2016: LDA %DP, H, sdcard[1]
0x5b, 0x00,	// 0x2018: LDA %DP, L, sdcard[0]

//	Set Byte 0 (Page) to 0x30
0x03, 0x30,	// 0x201a: LDR R0, dir_block_page
0x17, 0x00,	// 0x201c: SDW R0, %DP, DISK_MMIO_PAGE_OFFSET

//	Set Byte 1 (Sector High) to 0x00
0x03, 0x00,	// 0x201e: LDR R0, #0x00
0x17, 0x01,	// 0x2020: SDW R0, %DP, DISK_MMIO_SECTOR_HI_OFFSET

//	Set Byte 2 (Sector Low) to 0x08
0x03, 0x08,	// 0x2022: LDR R0, #0x08
0x17, 0x02,	// 0x2024: SDW R0, %DP, DISK_MMIO_SECTOR_LO_OFFSET

//	Write into Byte 3 (Go) (R0's value is ignored)
0x17, 0x03,	// 0x2026: SDW R0, %DP, DISK_MMIO_GO_OFFSET

//	At this point, the disk interface takes over the busses and copies sector 8
//	(block 8)'s contents into page 0x30.

//	3.	Set total_blocks (a 16-bit counter as there are 2048 total blocks in the
//		disk) to 0.
0x03, 0x00,	// 0x2028: LDR R0, #0x00
0x36, 0x00,	// 0x202a: SDW R0, %SP, sp_total_blocks_hi
0x36, 0xff,	// 0x202c: SDW R0, %SP, sp_total_blocks_lo

//	4.	For each directory entry (0 through 15):
//		R0: index of directory entry (i)
//		R1: Inode page (inode_arr_base_page + i)
//		DP: dir_block_page (0x3000) (points at current directory entry)
0x03, 0x00,	// 0x202e: LDR R0, #0						//	i = 0;
0x43, 0x31,	// 0x2030: LDR R1, inode_arr_base_page		//	inode_page = 0x31;
0x7b, 0x30,	// 0x2032: LDA %DP, H, dir_block_page		//	DirectoryEntry * entry = 0x3000;
0x5b, 0x00,	// 0x2034: LDA %DP, L, #0

:loop_1					//	for (; i < 16;) {
0xc3, 0x10,	// 0x2036: LDR R3, #16
0x12, 0xc7,	// 0x2038: TST R0, R3				//		R0 - 16 = i - 16 (since i < 16 -> i - 16 < 0)
0x3b, 0x10,	// 0x203a: BPL :loop_1_done		//		(Since if i < 16, i - 16 < 0 and negative flag is set)
0xa5, 0x3f,	// 0x203c: (BPL continued)

//		1.	If the inode block pointer of the current entry is 0, skip to the
//			next entry.
//							if (entry->inode_block_sector == 0) continue;
0x95, 0x0f,	// 0x203e: LDW R2, %DP, DirectoryEntry_inode_block_sector_offset_lo
0x93, 0x07,	// 0x2040: TST R2, #0
0x3b, 0x10,	// 0x2042: BNE :handle_dir_entry
0xe5, 0x29,	// 0x2044: (BNE continued)
0x95, 0x0e,	// 0x2046: LDW R2, %DP, DirectoryEntry_inode_block_sector_offset_hi
0x93, 0x07,	// 0x2048: TST R2, #0
0x3b, 0x10,	// 0x204a: BNE :handle_dir_entry
0xe5, 0x29,	// 0x204c: (BNE continued)
0x3b, 0x10,	// 0x204e: JMP :loop_1_update
0x05, 0x3a,	// 0x2050: (JMP continued)

:handle_dir_entry
//		2.	Load the inode block of the current entry at page 0x31 + i.
//			(Use BP as temp address register).
0xfb, 0xe0,	// 0x2052: LDA %BP, H, sdcard[1]
0xdb, 0x00,	// 0x2054: LDA %BP, L, sdcard[0]

//	Set Byte 0 (Page) to 0x31 + i (R1)
0x77, 0x00,	// 0x2056: SDW R1, %BP, DISK_MMIO_PAGE_OFFSET

//	Set Byte 1 (Sector High) to entry->inode_block_sector[1]
0x95, 0x0e,	// 0x2058: LDW R2, %DP, DirectoryEntry_inode_block_sector_offset_hi
0xb7, 0x01,	// 0x205a: SDW R2, %BP, DISK_MMIO_SECTOR_HI_OFFSET

//	Set Byte 2 (Sector Low) to entry->inode_block_sector[0]
0x95, 0x0f,	// 0x205c: LDW R2, %DP, DirectoryEntry_inode_block_sector_offset_lo
0xb7, 0x02,	// 0x205e: SDW R2, %BP, DISK_MMIO_SECTOR_LO_OFFSET

//	Write into Byte 3 (Go) (R0's value is ignored)
0x37, 0x03,	// 0x2060: SDW R0, %BP, DISK_MMIO_GO_OFFSET

//		3.	Increment total_blocks by the file size field (in blocks) in that
//			inode.
//			(Use BP as temp address register pointing at the inode in RAM).

//	Set BP to (inode_page << 8)
0xfc, 0x10,	// 0x2062: MGA %BP, H, R1
0xdb, 0x00,	// 0x2064: LDA %BP, L, #0

//	R2 = entry_inode->file_size_blocks. (offset: 2 bytes)
0xb5, 0x02,	// 0x2066: LDW R2, %BP, #2

//	Now need to read total_blocks; store total_blocks low in R3.
0xf4, 0xff,	// 0x2068: LDW R3, %SP, sp_total_blocks_lo

//	Add total_blocks low with file_size_blocks (R2)
0x82, 0xe6,	// 0x206a: ADD R2, R2, R3

//	Load total_blocks high in R3.
0xf4, 0x00,	// 0x206c: LDW R3, %SP, sp_total_blocks_hi

//	Add total_blocks_hi with 0 and carry.
0xc6, 0x0e,	// 0x206e: ADC R3, #0

//	Write total_blocks to stack.
0xf6, 0x00,	// 0x2070: SDW R3, %SP, sp_total_blocks_hi
0xb6, 0xff,	// 0x2072: SDW R2, %SP, sp_total_blocks_lo

:loop_1_update
//	Update variables:
//		R0: index of directory entry (i)
//		R1: Inode page (inode_arr_base_page + i)
//		DP: dir_block_page (0x3000) (points at current directory entry)
//	1.	R0 += 1
//	2.	R1 += 1
//	3.	DP += sizeof(DirectoryEntry) = 16
0x06, 0x16,	// 0x2074: INC R0
0x46, 0x16,	// 0x2076: INC R1
0x59, 0x10,	// 0x2078: MAA %DP, %DP, DIR_ENTRY_SIZE_BYTES
0x3b, 0x10,	// 0x207a: JMP :loop_1
0x05, 0x1b,	// 0x207c: (JMP continued)

:loop_1_done

//	5.	printf("total %hu\n", total_blocks);
0x0d, 0x74,	// 0x207e: OUT _t, A
0x0d, 0x6f,	// 0x2080: OUT _o, A
0x0d, 0x74,	// 0x2082: OUT _t, A
0x0d, 0x61,	// 0x2084: OUT _a, A
0x0d, 0x6c,	// 0x2086: OUT _l, A
0x0d, 0x20,	// 0x2088: OUT SPACE, A
0xb4, 0x00,	// 0x208a: LDW R2, %SP, sp_total_blocks_hi
//	Print high byte if not zero.
0x93, 0x07,	// 0x208c: TST R2, #0
0x3b, 0x10,	// 0x208e: BEQ :print_low_total_blocks
0x65, 0x4a,	// 0x2090: (BEQ continued)
0x28, 0x20,	// 0x2092: OUT R2, I
:print_low_total_blocks
0xb4, 0xff,	// 0x2094: LDW R2, %SP, sp_total_blocks_lo
0x28, 0x20,	// 0x2096: OUT R2, I

0x0d, 0x10,	// 0x2098: OUT NEW_LINE, A

//	6.	For each directory entry (0 through 15):
//		R0: index of directory entry (i)
//		R1: Inode page (inode_arr_base_page + i)
//		DP: dir_block_page (0x3000) (points at current directory entry)
//		BP: Inode entry (0x3100)
0x03, 0x00,	// 0x209a: LDR R0, #0						//	i = 0;
0x43, 0x31,	// 0x209c: LDR R1, inode_arr_base_page		//	inode_page = 0x31;
0x7b, 0x30,	// 0x209e: LDA %DP, H, dir_block_page		//	DirectoryEntry * entry = 0x3000;
0x5b, 0x00,	// 0x20a0: LDA %DP, L, #0
0xfb, 0x31,	// 0x20a2: LDA %BP, H, inode_arr_base_page	//	Inode * entry_inode = 0x3100;
0xdb, 0x00,	// 0x20a4: LDA %BP, L, #0

:loop_2					//	for (; i < 16;) {
0x0d, 0x2a,	// 0x20a6: OUT ASTERISK, A
0xc3, 0x10,	// 0x20a8: LDR R3, #16
0x12, 0xc7,	// 0x20aa: TST R0, R3 				//		R0 - 16 = i - 16 (since i < 16 -> i - 16 < 0)
0x3b, 0x10,	// 0x20ac: BPL :loop_2_done		//		(Since if i < 16, i - 16 < 0 and negative flag is set)
0xa5, 0x87,	// 0x20ae: (BPL continued)

//		1.	If the inode block pointer of the current entry is 0, skip to the
//			next entry.
//							if (entry->inode_block_sector == 0) continue;
0x95, 0x0f,	// 0x20b0: LDW R2, %DP, DirectoryEntry_inode_block_sector_offset_lo
0x93, 0x07,	// 0x20b2: TST R2, #0
0x3b, 0x10,	// 0x20b4: BNE :handle_dir_entry_2
0xe5, 0x62,	// 0x20b6: (BNE continued)
0x95, 0x0e,	// 0x20b8: LDW R2, %DP, DirectoryEntry_inode_block_sector_offset_hi
0x93, 0x07,	// 0x20ba: TST R2, #0
0x3b, 0x10,	// 0x20bc: BNE :handle_dir_entry_2
0xe5, 0x62,	// 0x20be: (BNE continued)
0x3b, 0x10,	// 0x20c0: JMP :loop_2_update
0x05, 0x81,	// 0x20c2: (JMP continued)

:handle_dir_entry_2

//		2.	Read the file size field in blocks of this entry's inode and print
//			it.

//	Read entry_node->file_size_blocks
0xb5, 0x02,	// 0x20c4: LDW R2, %BP, #2
0x28, 0x20,	// 0x20c6: OUT R2, I

//		3.	Print space.
0x0d, 0x20,	// 0x20c8: OUT SPACE, A

//		4.	Read the file size field in bytes of this entry's inode

//	Read entry_node->file_size_bytes HIGH byte
0xb5, 0x00,	// 0x20ca: LDW R2, %BP, #0
0x28, 0x20,	// 0x20cc: OUT R2, I

//	Read entry_node->file_size_bytes LOW byte
0xb5, 0x01,	// 0x20ce: LDW R2, %BP, #1
0x28, 0x20,	// 0x20d0: OUT R2, I

//		5.	Print space.
0x0d, 0x20,	// 0x20d2: OUT SPACE, A

//		6.	Print the filename.
//			1.	for (R2 = 0; R2 < 14;):
//				1.	R3 = *DP.
//				2.	if R3 == '\0', break
//				3.	Print R3
//				4.	R2++, DP++
//			2.	Move DP to next directory entry:
//				1.	for (R2 < 16):
//					1.	DP++, R2++
0x83, 0x00,	// 0x20d4: LDR R2, #0
:file_name_print_loop
0xc3, 0x0e,	// 0x20d6: LDR R3, #14
0x12, 0xe7,	// 0x20d8: TST R2, R3		//	R2 < 14 -> R2 - 14 < 0
0x3b, 0x10,	// 0x20da: BPL :file_name_print_loop_done
0xa5, 0x78,	// 0x20dc: (BPL continued)
0xd5, 0x00,	// 0x20de: LDW R3, %DP, #0
0xd3, 0x07,	// 0x20e0: TST R3, #0
0x3b, 0x10,	// 0x20e2: BEQ :file_name_print_loop_done
0x65, 0x78,	// 0x20e4: (BEQ continued)
0x08, 0x30,	// 0x20e6: OUT R3, A

0x86, 0x16,	// 0x20e8: INC R2
0x59, 0x01,	// 0x20ea: MAA %DP, %DP, #1
0x3b, 0x10,	// 0x20ec: JMP :file_name_print_loop
0x05, 0x6b,	// 0x20ee: (JMP continued)

:file_name_print_loop_done

:move_dp_to_next_entry_loop
0xc3, 0x10,	// 0x20f0: LDR R3, #16
0x12, 0xe7,	// 0x20f2: TST R2, R3
0x3b, 0x10,	// 0x20f4: BPL :move_dp_to_next_entry_loop_done
0xa5, 0x80,	// 0x20f6: (BPL continued)
0x86, 0x16,	// 0x20f8: INC R2
0x59, 0x01,	// 0x20fa: MAA %DP, %DP, #1
0x3b, 0x10,	// 0x20fc: JMP :move_dp_to_next_entry_loop
0x05, 0x78,	// 0x20fe: (JMP continued)

:move_dp_to_next_entry_loop_done

//			7.	Print newline.
0x0d, 0x10,	// 0x2100: OUT NEW_LINE, A

:loop_2_update
0x0d, 0x2c,	// 0x2102: OUT COMMA, A
0x06, 0x16,	// 0x2104: INC R0
0x46, 0x16,	// 0x2106: INC R1
0xfc, 0x10,	// 0x2108: MGA %BP, H, R1
0x3b, 0x10,	// 0x210a: JMP :loop_2
0x05, 0x53,	// 0x210c: (JMP continued)

:loop_2_done

//	7.	Print "$ "
0x0d, 0x24,	// 0x210e: OUT dollar, A
0x0d, 0x20,	// 0x2110: OUT SPACE, A

0x01, 0x00,	// 0x2112: BRK
