//	Binary Search Tree (Insert + traversal)
// :main_func      //  main()
//  Store elements in RAM
//  Store elements 3, 12, 4, and 0
0x03,  0x03, // 0x01: LDR R0, #3
0x43,  0x0c, // 0x02: LDR R1, #12
0x83,  0x04, // 0x03: LDR R2, #4
0xc3,  0x00, // 0x04: LDR R3, #0
0x0a,  0x01, // 0x05: SMA R0, #1
0x4a,  0x02, // 0x06: SMA R1, #2
0x8a,  0x03, // 0x07: SMA R2, #3
0xca,  0x04, // 0x08: SMA R3, #4
//  Store elements 36, 235, 89, 54
0x03,  0x24, // 0x09: LDR R0, #36
0x43,  0xeb, // 0x0a: LDR R1, #235
0x83,  0x59, // 0x0b: LDR R2, #89
0xc3,  0x36, // 0x0c: LDR R3, #54
0x0a,  0x05, // 0x0d: SMA R0, #5
0x4a,  0x06, // 0x0e: SMA R1, #6
0x8a,  0x07, // 0x0f: SMA R2, #7
0xca,  0x08, // 0x10: SMA R3, #8
//  Store elements 21, 100
0x83,  0x15, // 0x11: LDR R2, #21
0xc3,  0x64, // 0x12: LDR R3, #100
0x8a,  0x09, // 0x13: SMA R2, #9
0xca,  0x0a, // 0x14: SMA R3, #10
//  Create Binary Search Tree
0x03,  0x1e, // 0x15: LDR R0, #30		//	Set next_node = root address
0x0a,  0x0b, // 0x16: SMA R0, #11     //	.
//	Make the root node
0x09,  0x01, // 0x17: LMA R0, #1		//	R0 = elements[0]
0x0e,  0x00, // 0x18: PUSH R0			//	add_new_node(elements[0])
0x10,  0x2e, // 0x19: JSR :add_new_node_func	//	.
0x43,  0x02, // 0x1a: LDR R1, #2		//	i = 2
0x83,  0x0b, // 0x1b: LDR R2, #11		//	R2 = num_elements (11)
// :do_while
0x28,  0x10, // 0x1c: OUT R1, I		//	Print i
0x0d,  0x10, // 0x1d: OUT #0x10, A	//	Print '\n'
0x0e,  0x10, // 0x1e: PUSH R1			//	Save R1
0x0e,  0x20, // 0x1f: PUSH R2			//	Save R2
0xcb,  0x10, // 0x20: LMR R3, R1		//	R3 = element
0x0e,  0x30, // 0x21: PUSH R3			//	Push element
0xc3,  0x1e, // 0x22: LDR R3, #30		//	R3 = root address (30)
0x0e,  0x30, // 0x23: PUSH R3			//	Push root
0x10,  0x3d, // 0x24: JSR :insert_func	//	insert(tree, elements[i]);
//LDR R3, #30		//	R3 = root address (30)
//PUSH R3			//	Push root address
//JSR :traverse_func	//	traverse(root);
0x8f,  0x00, // 0x25: POP R2			//	Restore R2
0x4f,  0x00, // 0x26: POP R1			//	Restore R1
0x46,  0x16, // 0x27: INC R1			//	i++
0xc2,  0x97, // 0x28: SUB R3, R1, R2	//	while (i < num_elements);
0x25,  0x1b, // 0x29: BMI :do_while	//	.
0x03,  0x1e, // 0x2a: LDR R0, #30		//	R0 = root address (30)
0x0e,  0x00, // 0x2b: PUSH R0			//	Push root address
0x10,  0x72, // 0x2c: JSR :traverse_func	//	traverse(root);
0x0d,  0x10, // 0x2d: OUT #0x10, A		//	printf("\n");
0x01,  0x00, // 0x2e: BRK

// :add_new_node_func
0x0f,  0x00, // 0x2f: POP R0			//	R0 = return address
0x4f,  0x00, // 0x30: POP R1			//	R1 = element
0x89,  0x0b, // 0x31: LMA R2, #11		//	R2 = next_node
0x0e,  0x20, // 0x32: PUSH R2			//  push next_node
0x0e,  0x00, // 0x33: PUSH R0			// 	push return address
0x04,  0x20, // 0x34: MOV R0, R2		//	R0 = next_node
0x4c,  0x00, // 0x35: SMR R1, R0		//	next_node->value = element
0x06,  0x16, // 0x36: INC R0			//	R0 = &(next_node->left)
0x43,  0x00, // 0x37: LDR R1, #0		//	R1 = NULL
0x4c,  0x00, // 0x38: SMR R1, R0		//	next_node->left = NULL
0x06,  0x16, // 0x39: INC R0			//	R0 = &(next_node->right)
0x4c,  0x00, // 0x3a: SMR R1, R0		//	next_node->right = NULL
0x06,  0x16, // 0x3b: INC R0			//	R0 = next_node + 1
0x0a,  0x0b, // 0x3c: SMA R0, #11		//	next_node = R0 (next_node + 1)
0x11,  0x00, // 0x3d: RTS				//	return;

// :insert_func
0x0f,  0x00, // 0x3e: POP R0					//	R0 = return address
0x4f,  0x00, // 0x3f: POP R1					//	R1 = root (parameter variable)
0x8f,  0x00, // 0x40: POP R2					//	R2 = element (parameter variable)
0x0e,  0x00, // 0x41: PUSH R0					//	push return address
0x04,  0x10, // 0x42: MOV R0, R1				// 	R0 = root
0x44,  0x20, // 0x43: MOV R1, R2				//	R1 = element
0x8b,  0x00, // 0x44: LMR R2, R0				//	R2 = root->value
0xc2,  0x67, // 0x45: SUB R3, R2, R1			//	R3 = root->value - element
0xa5,  0x5b, // 0x46: BPL :insert_else_if		//	if (root->value < element) {
0x83,  0x02, // 0x47: LDR R2, #2				//	R2 = 2
0x82,  0x86, // 0x48: ADD R2, R0, R2			//	R2 = &(root->right)
0xcb,  0x20, // 0x49: LMR R3, R2				//	R3 = root->right
0xc6,  0x06, // 0x4a: ADD R3, #0				//	if (root->right == NULL)
0xe5,  0x56, // 0x4b: BNE :insert_if_else		//	.
0x0e,  0x00, // 0x4c: PUSH R0					//	Save R0
0x0e,  0x10, // 0x4d: PUSH R1					//	Save R1
0x0e,  0x20, // 0x4e: PUSH R2					//	Save R2
0x0e,  0x10, // 0x4f: PUSH R1					//	add_new_node(element);
0x10,  0x2e, // 0x50: JSR :add_new_node_func	//	.
0xcf,  0x00, // 0x51: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x52: POP R2					//	Restore R2
0x4f,  0x00, // 0x53: POP R1					//	Restore R1
0x0f,  0x00, // 0x54: POP R0					// 	Restore R0
0xcc,  0x20, // 0x55: SMR R3, R2				//	root->right = next_node (return value)
0x11,  0x00, // 0x56: RTS
// :insert_if_else
0x0e,  0x10, // 0x57: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x58: LMR R2, R2				//	R2 = root->right
0x0e,  0x20, // 0x59: PUSH R2					//	Push R2 (root->right)
0x10,  0x3d, // 0x5a: JSR :insert_func		//	insert(root->right, element);
0x11,  0x00, // 0x5b: RTS
// :insert_else_if
0xe5,  0x5d, // 0x5c: BNE :insert_else_if_if			// if (root->value == element) return;
0x11,  0x00, // 0x5d: RTS
// :insert_else_if_if
0x83,  0x01, // 0x5e: LDR R2, #1				//	R2 = 1
0x82,  0x86, // 0x5f: ADD R2, R0, R2			//	R2 = &(root->left)
0xcb,  0x20, // 0x60: LMR R3, R2				// 	R3 = root->left
0xc6,  0x06, // 0x61: ADD R3, #0					//	if (root->left == NULL)
0xe5,  0x6d, // 0x62: BNE :insert_else_if_else	//	.
0x0e,  0x00, // 0x63: PUSH R0					//	Save R0
0x0e,  0x10, // 0x64: PUSH R1					//	Save R1
0x0e,  0x20, // 0x65: PUSH R2					//	Save R2
0x0e,  0x10, // 0x66: PUSH R1					//	add_new_node(element);
0x10,  0x2e, // 0x67: JSR :add_new_node_func	//	.
0xcf,  0x00, // 0x68: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x69: POP R2					//	Restore R2
0x4f,  0x00, // 0x6a: POP R1					//	Restore R1
0x0f,  0x00, // 0x6b: POP R0					// 	Restore R0
0xcc,  0x20, // 0x6c: SMR R3, R2				//	root->left = next_node (return value)
0x11,  0x00, // 0x6d: RTS
// :insert_else_if_else
0x0e,  0x10, // 0x6e: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x6f: LMR R2, R2				//	R2 = root->left
0x0e,  0x20, // 0x70: PUSH R2					//	Push R2 (root->left)
0x10,  0x3d, // 0x71: JSR :insert_func		//	insert(root->left, element);
0x11,  0x00, // 0x72: RTS

// :traverse_func
0x0f,  0x00, // 0x73: POP	R0					//	R0 = return address
0x4f,  0x00, // 0x74: POP R1					//	R1 = root (parameter variable)
0x0e,  0x00, // 0x75: PUSH R0					// 	Push return address
0x46,  0x07, // 0x76: SUB R1, #0				// 	if (R1 (root) == NULL)
0xe5,  0x78, // 0x77: BNE :traverse_func_core	//	.
0x11,  0x00, // 0x78: RTS						//	return;
// :traverse_func_core
0x46,  0x16, // 0x79: INC R1					//	R1 = &(root->left)
0x0b,  0x10, // 0x7a: LMR R0, R1				//	R0 = root->left
0x0e,  0x10, // 0x7b: PUSH R1					//	Save R1
0x0e,  0x00, // 0x7c: PUSH R0					//	traverse(root->left);
0x10,  0x72, // 0x7d: JSR :traverse_func		//	.
0x4f,  0x00, // 0x7e: POP R1					//	Restore R1
0x46,  0x17, // 0x7f: DEC R1					//	R1 = &(root->value)
0x0b,  0x10, // 0x80: LMR R0, R1				//	R0 = root->value
0x28,  0x00, // 0x81: OUT R0, I				//	printf("%d", root->value);
0x0d,  0x20, // 0x82: OUT #0x20, A			//	printf(" ");
0x46,  0x26, // 0x83: ADD R1, #2				//	R1 = &(root->right)
0x0b,  0x10, // 0x84: LMR R0, R1				// 	R0 = root->right
0x0e,  0x00, // 0x85: PUSH R0					//	traverse(root->right);
0x10,  0x72, // 0x86: JSR :traverse_func		//	.
0x11,  0x00, // 0x87: RTS

