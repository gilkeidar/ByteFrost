//	Binary Search Tree (Insert + traversal)
//  main()
//  Store elements in RAM
//  Store elements 3, 12, 4, and 0
0x03,  0x03, // 0x01: LDR R0, #3
0x43,  0x0c, // 0x02: LDR R1, #12
0x83,  0x04, // 0x03: LDR R2, #4
0xc3,  0x00, // 0x04: LDR R3, #0
0x0a,  0x01, // 0x05: SMA R0, #1
0x4a,  0x02, // 0x06: SMA R1, #2
0x8a,  0x03, // 0x07: SMA R2, #3
0xca,  0x04, // 0x08: SMA R3, #4
//  Store elements 36, 235, 89, 54
0x03,  0x24, // 0x09: LDR R0, #36
0x43,  0xeb, // 0x0a: LDR R1, #235
0x83,  0x59, // 0x0b: LDR R2, #89
0xc3,  0x36, // 0x0c: LDR R3, #54
0x0a,  0x05, // 0x0d: SMA R0, #5
0x4a,  0x06, // 0x0e: SMA R1, #6
0x8a,  0x07, // 0x0f: SMA R2, #7
0xca,  0x08, // 0x10: SMA R3, #8
//  Store elements 21, 100
0x83,  0x15, // 0x11: LDR R2, #21
0xc3,  0x64, // 0x12: LDR R3, #100
0x8a,  0x09, // 0x13: SMA R2, #9
0xca,  0x0a, // 0x14: SMA R3, #10
//  Create Binary Search Tree
0x03,  0x1e, // 0x15: LDR R0, #30		//	Set next_node = root address
0x0a,  0x0b, // 0x16: SMA R0, #11     //	.
//	Make the root node
0x09,  0x01, // 0x17: LMA R0, #1		//	R0 = elements[0]
0x0e,  0x00, // 0x18: PUSH R0			//	add_new_node(elements[0])
0x10,  0x2c, // 0x19: JSR #0x2d		//	.
0x43,  0x02, // 0x1a: LDR R1, #2		//	i = 2
0x83,  0x0b, // 0x1b: LDR R2, #11		//	R2 = num_elements (11)
//	:do_while 
0x0e,  0x10, // 0x1c: PUSH R1			//	Save R1 
0x0e,  0x20, // 0x1d: PUSH R2			//	Save R2 
0xcb,  0x10, // 0x1e: LMR R3, R1		//	R3 = element 
0x0e,  0x30, // 0x1f: PUSH R3			//	Push element 
0xc3,  0x1e, // 0x20: LDR R3, #30		//	R3 = root address (30) 
0x0e,  0x30, // 0x21: PUSH R3			//	Push root 
0x10,  0x45, // 0x22: JSR #0x46		//	insert(tree, elements[i]);
0x8f,  0x00, // 0x23: POP R2			//	Restore R2
0x4f,  0x00, // 0x24: POP R1			//	Restore R1
0x46,  0x16, // 0x25: INC R1			//	i++
0x0e,  0x00, // 0x26: PUSH R0			//	Save R0
0x0e,  0x10, // 0x27: PUSH R1			//	Save R1
0x0e,  0x20, // 0x28: PUSH R2			//	Save R2
0x03,  0x1e, // 0x29: LDR R0, #30		//	R0 = root address (30)
0x0e,  0x00, // 0x2a: PUSH R0			//	Push root address
0x10,  0x78, // 0x2b: JSR #0x79		//	traverse(root);
0x0f,  0x00, // 0x2c: POP R0			//	Pop return value
0x8f,  0x00, // 0x2d: POP R2			//	Restore R2
0x4f,  0x00, // 0x2e: POP R1			//	Restore R1
0x0f,  0x00, // 0x2f: POP R0			//	Restore R0
0xc2,  0x97, // 0x30: SUB R3, R1, R2	//	while (i < num_elements);
0x25,  0x1b, // 0x31: BMI #0x1c		//	.
0x03,  0x1e, // 0x32: LDR R0, #30		//	R0 = root address (30)
0x0e,  0x00, // 0x33: PUSH R0			//	Push root address
0x10,  0x78, // 0x34: JSR #0x79		//	traverse(root);
0x0d,  0x10, // 0x35: OUT #0x10, A		//	printf("\n");
0x01,  0x00, // 0x36: BRK

//	:add_new_node_func
0x0f,  0x00, // 0x37: POP R0			//	R0 = return address
0x4f,  0x00, // 0x38: POP R1			//	R1 = element
0x89,  0x0b, // 0x39: LMA R2, #11		//	R2 = next_node
0x0e,  0x20, // 0x3a: PUSH R2			//  push next_node
0x0e,  0x00, // 0x3b: PUSH R0			// 	push return address
0x04,  0x20, // 0x3c: MOV R0, R2		//	R0 = next_node
0x4c,  0x00, // 0x3d: SMR R1, R0		//	next_node->value = element
0x06,  0x16, // 0x3e: INC R0			//	R0 = &(next_node->left)
0x43,  0x00, // 0x3f: LDR R1, #0		//	R1 = NULL
0x4c,  0x00, // 0x40: SMR R1, R0		//	next_node->left = NULL
0x06,  0x16, // 0x41: INC R0			//	R0 = &(next_node->right)
0x4c,  0x00, // 0x42: SMR R1, R0		//	next_node->right = NULL
0x06,  0x16, // 0x43: INC R0			//	R0 = next_node + 1
0x0a,  0x0b, // 0x44: SMA R0, #11		//	next_node = R0 (next_node + 1)
0x11,  0x00, // 0x45: RTS				//	return;

//	:insert_func
0x0f,  0x00, // 0x46: POP R0					//	R0 = return address
0x4f,  0x00, // 0x47: POP R1					//	R1 = root (parameter variable)
0x8f,  0x00, // 0x48: POP R2					//	R2 = element (parameter variable)
0x0e,  0x00, // 0x49: PUSH R0					//	push return address
0x04,  0x10, // 0x4a: MOV R0, R1				// 	R0 = root
0x44,  0x20, // 0x4b: MOV R1, R2				//	R1 = element
0x8b,  0x00, // 0x4c: LMR R2, R0				//	R2 = root->value
0xc2,  0x67, // 0x4d: SUB R3, R2, R1			//	R3 = root->value - element
0xa5,  0x62, // 0x4e: BPL #0x63				//	if (root->value < element) {
0x83,  0x02, // 0x4f: LDR R2, #2				//	R2 = 2
0x82,  0x86, // 0x50: ADD R2, R0, R2			//	R2 = &(root->right)
0xcb,  0x20, // 0x51: LMR R3, R2				//	R3 = root->right
0xe5,  0x5d, // 0x52: BNE #0x5e				//	if (root->right == NULL)
0x0e,  0x00, // 0x53: PUSH R0					//	Save R0
0x0e,  0x10, // 0x54: PUSH R1					//	Save R1
0x0e,  0x20, // 0x55: PUSH R2					//	Save R2
0x0e,  0x10, // 0x56: PUSH R1					//	add_new_node(element);
0x10,  0x36, // 0x57: JSR #0x37				//	.
0xcf,  0x00, // 0x58: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x59: POP R2					//	Restore R2
0x4f,  0x00, // 0x5a: POP R1					//	Restore R1
0x0f,  0x00, // 0x5b: POP R0					// 	Restore R0
0xcb,  0x20, // 0x5c: LMR R3, R2				//	root->right = next_node (return value)
0x11,  0x00, // 0x5d: RTS
//	:insert_if_else
0x0e,  0x10, // 0x5e: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x5f: LMR R2, R2				//	R2 = root->right
0x0e,  0x20, // 0x60: PUSH R2					//	Push R2 (root->right)
0x10,  0x45, // 0x61: JSR #0x46				//	insert(root->right, element);
0x11,  0x00, // 0x62: RTS
//	:insert_else_if
0xe5,  0x64, // 0x63: BNE #0x65				// if (root->value == element) return;
0x11,  0x00, // 0x64: RTS
//	:insert_else_if_if
0x83,  0x01, // 0x65: LDR R2, #1				// 	R2 = 1
0x82,  0x86, // 0x66: ADD R2, R0, R2			//	R2 = &(root->left)
0xcb,  0x20, // 0x67: LMR R3, R2				// 	R3 = root->left
0xe5,  0x73, // 0x68: BNE #0x74
0x0e,  0x00, // 0x69: PUSH R0					//	Save R0
0x0e,  0x10, // 0x6a: PUSH R1					//	Save R1
0x0e,  0x20, // 0x6b: PUSH R2					//	Save R2
0x0e,  0x10, // 0x6c: PUSH R1					//	add_new_node(element);
0x10,  0x36, // 0x6d: JSR #0x37				//	.
0xcf,  0x00, // 0x6e: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x6f: POP R2					//	Restore R2
0x4f,  0x00, // 0x70: POP R1					//	Restore R1
0x0f,  0x00, // 0x71: POP R0					// 	Restore R0
0xcb,  0x20, // 0x72: LMR R3, R2				//	root->left = next_node (return value)
0x11,  0x00, // 0x73: RTS
//	:insert_else_if_else
0x0e,  0x10, // 0x74: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x75: LMR R2, R2				//	R2 = root->left
0x0e,  0x20, // 0x76: PUSH R2					//	Push R2 (root->left)
0x10,  0x45, // 0x77: JSR #0x46				//	insert(root->left, element);
0x11,  0x00, // 0x78: RTS

//	:traverse_func
0x0f,  0x00, // 0x79: POP	R0					//	R0 = return address
0x4f,  0x00, // 0x7a: POP R1					//	R1 = root (parameter variable)
0x0e,  0x00, // 0x7b: PUSH R0					// 	Push return address
0x46,  0x07, // 0x7c: SUB R1, #0				// 	if (R1 (root) == NULL)
0xe5,  0x7e, // 0x7d: BNE #0x7f				//	.
0x11,  0x00, // 0x7e: RTS						//	return;
//	:traverse_func_core
0x46,  0x16, // 0x7f: INC R1					//	R1 = &(root->left)
0x0b,  0x10, // 0x80: LMR R0, R1				//	R0 = root->left
0x0e,  0x10, // 0x81: PUSH R1					//	Save R1
0x0e,  0x00, // 0x82: PUSH R0					//	traverse(root->left);
0x10,  0x78, // 0x83: JSR #0x79				//	.
0x4f,  0x00, // 0x84: POP R1					//	Restore R1
0x46,  0x17, // 0x85: DEC R1					//	R1 = &(root->value)
0x0b,  0x10, // 0x86: LMR R0, R1				//	R0 = root->value
0x28,  0x00, // 0x87: OUT R0, I				//	printf("%d", root->value);
0x0d,  0x20, // 0x88: OUT #0x20, A			//	printf(" ");
0x46,  0x26, // 0x89: ADD R1, #2				//	R1 = &(root->right)
0x0b,  0x10, // 0x8a: LMR R0, R1				// 	R0 = root->right
0x0e,  0x00, // 0x8b: PUSH R0					//	traverse(root->right);
0x10,  0x78, // 0x8c: JSR #0x79				//	.
0x11,  0x00, // 0x8d: RTS
