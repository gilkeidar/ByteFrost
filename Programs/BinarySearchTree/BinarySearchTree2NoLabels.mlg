//	Binary Search Tree (Insert + traversal)
//  main()
//  Store elements in RAM
//  Store elements 3, 12, 4, and 0
0x03,  0x03, // 0x01: LDR R0, #3
0x43,  0x0c, // 0x02: LDR R1, #12
0x83,  0x04, // 0x03: LDR R2, #4
0xc3,  0x00, // 0x04: LDR R3, #0
0x0a,  0x01, // 0x05: SMA R0, #1
0x4a,  0x02, // 0x06: SMA R1, #2
0x8a,  0x03, // 0x07: SMA R2, #3
0xca,  0x04, // 0x08: SMA R3, #4
//  Store elements 36, 235, 89, 54
0x03,  0x24, // 0x09: LDR R0, #36
0x43,  0xeb, // 0x0a: LDR R1, #235
0x83,  0x59, // 0x0b: LDR R2, #89
0xc3,  0x36, // 0x0c: LDR R3, #54
0x0a,  0x05, // 0x0d: SMA R0, #5
0x4a,  0x06, // 0x0e: SMA R1, #6
0x8a,  0x07, // 0x0f: SMA R2, #7
0xca,  0x08, // 0x10: SMA R3, #8
//  Store elements 21, 100
0x83,  0x15, // 0x11: LDR R2, #21
0xc3,  0x64, // 0x12: LDR R3, #100
0x8a,  0x09, // 0x13: SMA R2, #9
0xca,  0x0a, // 0x14: SMA R3, #10
//  Create Binary Search Tree
0x03,  0x1e, // 0x15: LDR R0, #30		//	Set next_node = root address
0x0a,  0x0b, // 0x16: SMA R0, #11     //	.
//	Make the root node
0x09,  0x01, // 0x17: LMA R0, #1		//	R0 = elements[0]
0x0e,  0x00, // 0x18: PUSH R0			//	add_new_node(elements[0])
0x10,  0x2b, // 0x19: JSR #0x2c		//	.
0x43,  0x02, // 0x1a: LDR R1, #2		//	i = 2
0x83,  0x0b, // 0x1b: LDR R2, #11		//	R2 = num_elements (11)
//	:do_while
0x0e,  0x10, // 0x1c: PUSH R1			//	Save R1
0x0e,  0x20, // 0x1d: PUSH R2			//	Save R2
0xcb,  0x10, // 0x1e: LMR R3, R1		//	R3 = element
0x0e,  0x30, // 0x1f: PUSH R3			//	Push element
0xc3,  0x1e, // 0x20: LDR R3, #30		//	R3 = root address (30)
0x0e,  0x30, // 0x21: PUSH R3			//	Push root
0x10,  0x3a, // 0x22: JSR #0x3b		//	insert(tree, elements[i]);
0x8f,  0x00, // 0x23: POP R2			//	Restore R2
0x4f,  0x00, // 0x24: POP R1			//	Restore R1
0xc2,  0x97, // 0x25: SUB R3, R1, R2	//	while (i < num_elements);
0x25,  0x1b, // 0x26: BMI #0x1c		//	.
0x03,  0x1e, // 0x27: LDR R0, #30		//	R0 = root address (30)
0x0e,  0x00, // 0x28: PUSH R0			//	Push root address
0x10,  0x6d, // 0x29: JSR #0x6e		//	traverse(root);
0x0d,  0x10, // 0x2a: OUT #0x10, A		//	printf("\n");
0x01,  0x00, // 0x2b: BRK

//	:add_new_node_func
0x0f,  0x00, // 0x2c: POP R0			//	R0 = return address
0x4f,  0x00, // 0x2d: POP R1			//	R1 = element
0x89,  0x0b, // 0x2e: LMA R2, #11		//	R2 = next_node
0x0e,  0x20, // 0x2f: PUSH R2			//  push next_node
0x0e,  0x00, // 0x30: PUSH R0			// 	push return address
0x04,  0x20, // 0x31: MOV R0, R2		//	R0 = next_node
0x4c,  0x00, // 0x32: SMR R1, R0		//	next_node->value = element
0x06,  0x16, // 0x33: INC R0			//	R0 = &(next_node->left)
0x43,  0x00, // 0x34: LDR R1, #0		//	R1 = NULL
0x4c,  0x00, // 0x35: SMR R1, R0		//	next_node->left = NULL
0x06,  0x16, // 0x36: INC R0			//	R0 = &(next_node->right)
0x4c,  0x00, // 0x37: SMR R1, R0		//	next_node->right = NULL
0x06,  0x16, // 0x38: INC R0			//	R0 = next_node + 1
0x0a,  0x0b, // 0x39: SMA R0, #11		//	next_node = R0 (next_node + 1)
0x11,  0x00, // 0x3a: RTS				//	return;

//	:insert_func
0x0f,  0x00, // 0x3b: POP R0					//	R0 = return address
0x4f,  0x00, // 0x3c: POP R1					//	R1 = root (parameter variable)
0x8f,  0x00, // 0x3d: POP R2					//	R2 = element (parameter variable)
0x0e,  0x00, // 0x3e: PUSH R0					//	push return address
0x04,  0x10, // 0x3f: MOV R0, R1				// 	R0 = root
0x44,  0x20, // 0x40: MOV R1, R2				//	R1 = element
0x8b,  0x00, // 0x41: LMR R2, R0				//	R2 = root->value
0xc2,  0x67, // 0x42: SUB R3, R2, R1			//	R3 = root->value - element
0xa5,  0x57, // 0x43: BPL #0x58				//	if (root->value < element) {
0x83,  0x02, // 0x44: LDR R2, #2				//	R2 = 2
0x82,  0x86, // 0x45: ADD R2, R0, R2			//	R2 = &(root->right)
0xcb,  0x20, // 0x46: LMR R3, R2				//	R3 = root->right
0xe5,  0x52, // 0x47: BNE #0x53				//	if (root->right == NULL)
0x0e,  0x00, // 0x48: PUSH R0					//	Save R0
0x0e,  0x10, // 0x49: PUSH R1					//	Save R1
0x0e,  0x20, // 0x4a: PUSH R2					//	Save R2
0x0e,  0x10, // 0x4b: PUSH R1					//	add_new_node(element);
0x10,  0x2b, // 0x4c: JSR #0x2c				//	.
0xcf,  0x00, // 0x4d: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x4e: POP R2					//	Restore R2
0x4f,  0x00, // 0x4f: POP R1					//	Restore R1
0x0f,  0x00, // 0x50: POP R0					// 	Restore R0
0xcb,  0x20, // 0x51: LMR R3, R2				//	root->right = next_node (return value)
0x11,  0x00, // 0x52: RTS
//	:insert_if_else
0x0e,  0x10, // 0x53: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x54: LMR R2, R2				//	R2 = root->right
0x0e,  0x20, // 0x55: PUSH R2					//	Push R2 (root->right)
0x10,  0x3a, // 0x56: JSR #0x3b				//	insert(root->right, element);
0x11,  0x00, // 0x57: RTS
//	:insert_else_if
0xe5,  0x59, // 0x58: BNE #0x5a				// if (root->value == element) return;
0x11,  0x00, // 0x59: RTS
//	:insert_else_if_if
0x83,  0x01, // 0x5a: LDR R2, #1				// 	R2 = 1
0x82,  0x86, // 0x5b: ADD R2, R0, R2			//	R2 = &(root->left)
0xcb,  0x20, // 0x5c: LMR R3, R2				// 	R3 = root->left
0xe5,  0x68, // 0x5d: BNE #0x69
0x0e,  0x00, // 0x5e: PUSH R0					//	Save R0
0x0e,  0x10, // 0x5f: PUSH R1					//	Save R1
0x0e,  0x20, // 0x60: PUSH R2					//	Save R2
0x0e,  0x10, // 0x61: PUSH R1					//	add_new_node(element);
0x10,  0x2b, // 0x62: JSR #0x2c				//	.
0xcf,  0x00, // 0x63: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x64: POP R2					//	Restore R2
0x4f,  0x00, // 0x65: POP R1					//	Restore R1
0x0f,  0x00, // 0x66: POP R0					// 	Restore R0
0xcb,  0x20, // 0x67: LMR R3, R2				//	root->left = next_node (return value)
0x11,  0x00, // 0x68: RTS
//	:insert_else_if_else
0x0e,  0x10, // 0x69: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x6a: LMR R2, R2				//	R2 = root->left
0x0e,  0x20, // 0x6b: PUSH R2					//	Push R2 (root->left)
0x10,  0x3a, // 0x6c: JSR #0x3b				//	insert(root->left, element);
0x11,  0x00, // 0x6d: RTS

//	:traverse_func
0x0f,  0x00, // 0x6e: POP	R0					//	R0 = return address
0x4f,  0x00, // 0x6f: POP R1					//	R1 = root (parameter variable)
0x0e,  0x00, // 0x70: PUSH R0					// 	Push return address
0x46,  0x07, // 0x71: SUB R1, #0				// 	if (R1 (root) == NULL)
0xe5,  0x73, // 0x72: BNE #0x74				//	.
0x11,  0x00, // 0x73: RTS						//	return;
//	:traverse_func_core
0x46,  0x16, // 0x74: INC R1					//	R1 = &(root->left)
0x0b,  0x10, // 0x75: LMR R0, R1				//	R0 = root->left
0x0e,  0x10, // 0x76: PUSH R1					//	Save R1
0x0e,  0x00, // 0x77: PUSH R0					//	traverse(root->left);
0x10,  0x6d, // 0x78: JSR #0x6e				//	.
0x4f,  0x00, // 0x79: POP R1					//	Restore R1
0x46,  0x17, // 0x7a: DEC R1					//	R1 = &(root->value)
0x0b,  0x10, // 0x7b: LMR R0, R1				//	R0 = root->value
0x28,  0x00, // 0x7c: OUT R0, I				//	printf("%d", root->value);
0x0d,  0x20, // 0x7d: OUT #0x20, A			//	printf(" ");
0x46,  0x26, // 0x7e: ADD R1, #2				//	R1 = &(root->right)
0x0b,  0x10, // 0x7f: LMR R0, R1				// 	R0 = root->right
0x0e,  0x00, // 0x80: PUSH R0					//	traverse(root->right);
0x10,  0x6d, // 0x81: JSR #0x6e				//	.
0x11,  0x00, // 0x82: RTS
