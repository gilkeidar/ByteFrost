//	Binary Search Tree (Insert + traversal)

// :main_func      //  main()

//  Store elements in RAM

//  Store elements 3, 12, 4, and 0

0x03,  0x03, // 0x85: LDR R0, #3

0x43,  0x0c, // 0x86: LDR R1, #12

0x83,  0x04, // 0x87: LDR R2, #4

0xc3,  0x00, // 0x88: LDR R3, #0

0x0a,  0x01, // 0x89: SMA R0, #1

0x4a,  0x02, // 0x8a: SMA R1, #2

0x8a,  0x03, // 0x8b: SMA R2, #3

0xca,  0x04, // 0x8c: SMA R3, #4

//  Store elements 36, 235, 89, 54

0x03,  0x24, // 0x8d: LDR R0, #36

0x43,  0xeb, // 0x8e: LDR R1, #235

0x83,  0x59, // 0x8f: LDR R2, #89

0xc3,  0x36, // 0x90: LDR R3, #54

0x0a,  0x05, // 0x91: SMA R0, #5

0x4a,  0x06, // 0x92: SMA R1, #6

0x8a,  0x07, // 0x93: SMA R2, #7

0xca,  0x08, // 0x94: SMA R3, #8

//  Store elements 21, 100

0x83,  0x15, // 0x95: LDR R2, #21

0xc3,  0x64, // 0x96: LDR R3, #100

0x8a,  0x09, // 0x97: SMA R2, #9

0xca,  0x0a, // 0x98: SMA R3, #10

//  Create Binary Search Tree

0x03,  0x1e, // 0x99: LDR R0, #30		//	Set next_node = root address

0x0a,  0x0b, // 0x9a: SMA R0, #11     //	.

//	Make the root node

0x09,  0x01, // 0x9b: LMA R0, #1		//	R0 = elements[0]

0x0e,  0x00, // 0x9c: PUSH R0			//	add_new_node(elements[0])

0x10,  0x2c, // 0x9d: JSR :add_new_node_func	//	.

0x43,  0x01, // 0x9e: LDR R1, #1		//	i = 1

0x83,  0x0a, // 0x9f: LDR R2, #10		//	R2 = num_elements (10)

// :do_while

0x0e,  0x10, // 0xa0: PUSH R1			//	Save R1

0x0e,  0x20, // 0xa1: PUSH R2			//	Save R2

0xcb,  0x10, // 0xa2: LMR R3, R1		//	R3 = element

0x0e,  0x30, // 0xa3: PUSH R3			//	Push element

0xc3,  0x1e, // 0xa4: LDR R3, #30		//	R3 = root address (30)

0x0e,  0x30, // 0xa5: PUSH R3			//	Push root

0x10,  0x3b, // 0xa6: JSR :insert_func	//	insert(tree, elements[i]);

0x8f,  0x00, // 0xa7: POP R2			//	Restore R2

0x4f,  0x00, // 0xa8: POP R1			//	Restore R1

0xc2,  0x97, // 0xa9: SUB R3, R1, R2	//	while (i < num_elements);

0x46,  0x16, // 0xaa: INC R1			//	i++

0x25,  0x1b, // 0xab: BMI :do_while	//	.

0x03,  0x1e, // 0xac: LDR R0, #30		//	R0 = root address (30)

0x0e,  0x00, // 0xad: PUSH R0			//	Push root address

0x10,  0x6f, // 0xae: JSR :traverse_func	//	traverse(root);

0x0d,  0x10, // 0xaf: OUT #0x10, A		//	printf("\n");

0x01,  0x00, // 0xb0: BRK



// :add_new_node_func

0x0f,  0x00, // 0xb1: POP R0			//	R0 = return address

0x4f,  0x00, // 0xb2: POP R1			//	R1 = element

0x89,  0x0b, // 0xb3: LMA R2, #11		//	R2 = next_node

0x0e,  0x20, // 0xb4: PUSH R2			//  push next_node

0x0e,  0x00, // 0xb5: PUSH R0			// 	push return address

0x04,  0x20, // 0xb6: MOV R0, R2		//	R0 = next_node

0x4c,  0x00, // 0xb7: SMR R1, R0		//	next_node->value = element

0x06,  0x16, // 0xb8: INC R0			//	R0 = &(next_node->left)

0x43,  0x00, // 0xb9: LDR R1, #0		//	R1 = NULL

0x4c,  0x00, // 0xba: SMR R1, R0		//	next_node->left = NULL

0x06,  0x16, // 0xbb: INC R0			//	R0 = &(next_node->right)

0x4c,  0x00, // 0xbc: SMR R1, R0		//	next_node->right = NULL

0x06,  0x16, // 0xbd: INC R0			//	R0 = next_node + 1

0x0a,  0x0b, // 0xbe: SMA R0, #11		//	next_node = R0 (next_node + 1)

0x11,  0x00, // 0xbf: RTS				//	return;



// :insert_func

0x0f,  0x00, // 0xc0: POP R0					//	R0 = return address

0x4f,  0x00, // 0xc1: POP R1					//	R1 = root (parameter variable)

0x8f,  0x00, // 0xc2: POP R2					//	R2 = element (parameter variable)

0x0e,  0x00, // 0xc3: PUSH R0					//	push return address

0x04,  0x10, // 0xc4: MOV R0, R1				// 	R0 = root

0x44,  0x20, // 0xc5: MOV R1, R2				//	R1 = element

0x8b,  0x00, // 0xc6: LMR R2, R0				//	R2 = root->value

0xc2,  0x67, // 0xc7: SUB R3, R2, R1			//	R3 = root->value - element

0xa5,  0x59, // 0xc8: BPL :insert_else_if		//	if (root->value < element) {

0x83,  0x02, // 0xc9: LDR R2, #2				//	R2 = 2

0x82,  0x86, // 0xca: ADD R2, R0, R2			//	R2 = &(root->right)

0xcb,  0x20, // 0xcb: LMR R3, R2				//	R3 = root->right

0xc6,  0x06, // 0xcc: ADD R3, #0				//	if (root->right == NULL)

0xe5,  0x54, // 0xcd: BNE :insert_if_else		//	.

0x0e,  0x00, // 0xce: PUSH R0					//	Save R0

0x0e,  0x10, // 0xcf: PUSH R1					//	Save R1

0x0e,  0x20, // 0xd0: PUSH R2					//	Save R2

0x0e,  0x10, // 0xd1: PUSH R1					//	add_new_node(element);

0x10,  0x2c, // 0xd2: JSR :add_new_node_func	//	.

0xcf,  0x00, // 0xd3: POP R3					//	R3 = next_node (return value)

0x8f,  0x00, // 0xd4: POP R2					//	Restore R2

0x4f,  0x00, // 0xd5: POP R1					//	Restore R1

0x0f,  0x00, // 0xd6: POP R0					// 	Restore R0

0xcb,  0x20, // 0xd7: LMR R3, R2				//	root->right = next_node (return value)

0x11,  0x00, // 0xd8: RTS

// :insert_if_else

0x0e,  0x10, // 0xd9: PUSH R1					//	Push R1 (element)

0x8b,  0x20, // 0xda: LMR R2, R2				//	R2 = root->right

0x0e,  0x20, // 0xdb: PUSH R2					//	Push R2 (root->right)

0x10,  0x3b, // 0xdc: JSR :insert_func		//	insert(root->right, element);

0x11,  0x00, // 0xdd: RTS

// :insert_else_if

0xe5,  0x5b, // 0xde: BNE :insert_else_if_if			// if (root->value == element) return;

0x11,  0x00, // 0xdf: RTS

// :insert_else_if_if

0x83,  0x01, // 0xe0: LDR R2, #1				//	R2 = 1

0x82,  0x86, // 0xe1: ADD R2, R0, R2			//	R2 = &(root->left)

0xcb,  0x20, // 0xe2: LMR R3, R2				// 	R3 = root->left

0xe5,  0x6a, // 0xe3: BNE :insert_else_if_else

0x0e,  0x00, // 0xe4: PUSH R0					//	Save R0

0x0e,  0x10, // 0xe5: PUSH R1					//	Save R1

0x0e,  0x20, // 0xe6: PUSH R2					//	Save R2

0x0e,  0x10, // 0xe7: PUSH R1					//	add_new_node(element);

0x10,  0x2c, // 0xe8: JSR :add_new_node_func	//	.

0xcf,  0x00, // 0xe9: POP R3					//	R3 = next_node (return value)

0x8f,  0x00, // 0xea: POP R2					//	Restore R2

0x4f,  0x00, // 0xeb: POP R1					//	Restore R1

0x0f,  0x00, // 0xec: POP R0					// 	Restore R0

0xcb,  0x20, // 0xed: LMR R3, R2				//	root->left = next_node (return value)

0x11,  0x00, // 0xee: RTS

// :insert_else_if_else

0x0e,  0x10, // 0xef: PUSH R1					//	Push R1 (element)

0x8b,  0x20, // 0xf0: LMR R2, R2				//	R2 = root->left

0x0e,  0x20, // 0xf1: PUSH R2					//	Push R2 (root->left)

0x10,  0x3b, // 0xf2: JSR :insert_func		//	insert(root->left, element);

0x11,  0x00, // 0xf3: RTS



// :traverse_func

0x0f,  0x00, // 0xf4: POP	R0					//	R0 = return address

0x4f,  0x00, // 0xf5: POP R1					//	R1 = root (parameter variable)

0x0e,  0x00, // 0xf6: PUSH R0					// 	Push return address

0x46,  0x07, // 0xf7: SUB R1, #0				// 	if (R1 (root) == NULL)

0xe5,  0x75, // 0xf8: BNE :traverse_func_core	//	.

0x11,  0x00, // 0xf9: RTS						//	return;

// :traverse_func_core

0x46,  0x16, // 0xfa: INC R1					//	R1 = &(root->left)

0x0b,  0x10, // 0xfb: LMR R0, R1				//	R0 = root->left

0x0e,  0x10, // 0xfc: PUSH R1					//	Save R1

0x0e,  0x00, // 0xfd: PUSH R0					//	traverse(root->left);

0x10,  0x6f, // 0xfe: JSR :traverse_func		//	.

0x4f,  0x00, // 0xff: POP R1					//	Restore R1

0x46,  0x17, // 0x100: DEC R1					//	R1 = &(root->value)

0x0b,  0x10, // 0x101: LMR R0, R1				//	R0 = root->value

0x28,  0x00, // 0x102: OUT R0, I				//	printf("%d", root->value);

0x0d,  0x20, // 0x103: OUT #0x20, A			//	printf(" ");

0x46,  0x26, // 0x104: ADD R1, #2				//	R1 = &(root->right)

0x0b,  0x10, // 0x105: LMR R0, R1				// 	R0 = root->right

0x0e,  0x00, // 0x106: PUSH R0					//	traverse(root->right);

0x10,  0x6f, // 0x107: JSR :traverse_func		//	.

0x11,  0x00, // 0x108: RTS


