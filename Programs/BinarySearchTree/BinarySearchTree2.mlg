//	Binary Search Tree (Insert + traversal)
// :main_func      //  main()
//  Store elements in RAM
//  Store elements 3, 12, 4, and 0
0x03,  0x03, // 0x01: LDR R0, #3
0x43,  0x0c, // 0x02: LDR R1, #12
0x83,  0x04, // 0x03: LDR R2, #4
0xc3,  0x00, // 0x04: LDR R3, #0
0x0a,  0x01, // 0x05: SMA R0, #1
0x4a,  0x02, // 0x06: SMA R1, #2
0x8a,  0x03, // 0x07: SMA R2, #3
0xca,  0x04, // 0x08: SMA R3, #4
//  Store elements 36, 235, 89, 54
0x03,  0x24, // 0x09: LDR R0, #36
0x43,  0xeb, // 0x0a: LDR R1, #235
0x83,  0x59, // 0x0b: LDR R2, #89
0xc3,  0x36, // 0x0c: LDR R3, #54
0x0a,  0x05, // 0x0d: SMA R0, #5
0x4a,  0x06, // 0x0e: SMA R1, #6
0x8a,  0x07, // 0x0f: SMA R2, #7
0xca,  0x08, // 0x10: SMA R3, #8
//  Store elements 21, 100
0x83,  0x15, // 0x11: LDR R2, #21
0xc3,  0x64, // 0x12: LDR R3, #100
0x8a,  0x09, // 0x13: SMA R2, #9
0xca,  0x0a, // 0x14: SMA R3, #10
//  Create Binary Search Tree
0x03,  0x1e, // 0x15: LDR R0, #30		//	Set next_node = root address
0x0a,  0x0b, // 0x16: SMA R0, #11     //	.
//	Make the root node
0x09,  0x01, // 0x17: LMA R0, #1		//	R0 = elements[0]
0x0e,  0x00, // 0x18: PUSH R0			//	add_new_node(elements[0])
0x10,  0x31, // 0x19: JSR :add_new_node_func	//	.
0x43,  0x01, // 0x1a: LDR R1, #1		//	i = 1
0x83,  0x0a, // 0x1b: LDR R2, #10		//	R2 = num_elements (10)
// :do_while
0x28,  0x10, // 0x1c: OUT R1, I		//	Print i
0x0d,  0x10, // 0x1d: OUT #0x10, A	//	Print '\n'
0x0e,  0x10, // 0x1e: PUSH R1			//	Save R1
0x0e,  0x20, // 0x1f: PUSH R2			//	Save R2
0xcb,  0x10, // 0x20: LMR R3, R1		//	R3 = element
0x0e,  0x30, // 0x21: PUSH R3			//	Push element
0xc3,  0x1e, // 0x22: LDR R3, #30		//	R3 = root address (30)
0x0e,  0x30, // 0x23: PUSH R3			//	Push root
0x10,  0x40, // 0x24: JSR :insert_func	//	insert(tree, elements[i]);
0xc3,  0x1e, // 0x25: LDR R3, #30		//	R3 = root address (30)
0x0e,  0x30, // 0x26: PUSH R3			//	Push root address
0x10,  0x75, // 0x27: JSR :traverse_func	//	traverse(root);
0x8f,  0x00, // 0x28: POP R2			//	Restore R2
0x4f,  0x00, // 0x29: POP R1			//	Restore R1
0x46,  0x16, // 0x2a: INC R1			//	i++
0xc2,  0x97, // 0x2b: SUB R3, R1, R2	//	while (i < num_elements);
0x25,  0x1b, // 0x2c: BMI :do_while	//	.
0x03,  0x1e, // 0x2d: LDR R0, #30		//	R0 = root address (30)
0x0e,  0x00, // 0x2e: PUSH R0			//	Push root address
0x10,  0x75, // 0x2f: JSR :traverse_func	//	traverse(root);
0x0d,  0x10, // 0x30: OUT #0x10, A		//	printf("\n");
0x01,  0x00, // 0x31: BRK

// :add_new_node_func
0x0f,  0x00, // 0x32: POP R0			//	R0 = return address
0x4f,  0x00, // 0x33: POP R1			//	R1 = element
0x89,  0x0b, // 0x34: LMA R2, #11		//	R2 = next_node
0x0e,  0x20, // 0x35: PUSH R2			//  push next_node
0x0e,  0x00, // 0x36: PUSH R0			// 	push return address
0x04,  0x20, // 0x37: MOV R0, R2		//	R0 = next_node
0x4c,  0x00, // 0x38: SMR R1, R0		//	next_node->value = element
0x06,  0x16, // 0x39: INC R0			//	R0 = &(next_node->left)
0x43,  0x00, // 0x3a: LDR R1, #0		//	R1 = NULL
0x4c,  0x00, // 0x3b: SMR R1, R0		//	next_node->left = NULL
0x06,  0x16, // 0x3c: INC R0			//	R0 = &(next_node->right)
0x4c,  0x00, // 0x3d: SMR R1, R0		//	next_node->right = NULL
0x06,  0x16, // 0x3e: INC R0			//	R0 = next_node + 1
0x0a,  0x0b, // 0x3f: SMA R0, #11		//	next_node = R0 (next_node + 1)
0x11,  0x00, // 0x40: RTS				//	return;

// :insert_func
0x0f,  0x00, // 0x41: POP R0					//	R0 = return address
0x4f,  0x00, // 0x42: POP R1					//	R1 = root (parameter variable)
0x8f,  0x00, // 0x43: POP R2					//	R2 = element (parameter variable)
0x0e,  0x00, // 0x44: PUSH R0					//	push return address
0x04,  0x10, // 0x45: MOV R0, R1				// 	R0 = root
0x44,  0x20, // 0x46: MOV R1, R2				//	R1 = element
0x8b,  0x00, // 0x47: LMR R2, R0				//	R2 = root->value
0xc2,  0x67, // 0x48: SUB R3, R2, R1			//	R3 = root->value - element
0xa5,  0x5e, // 0x49: BPL :insert_else_if		//	if (root->value < element) {
0x83,  0x02, // 0x4a: LDR R2, #2				//	R2 = 2
0x82,  0x86, // 0x4b: ADD R2, R0, R2			//	R2 = &(root->right)
0xcb,  0x20, // 0x4c: LMR R3, R2				//	R3 = root->right
0xc6,  0x06, // 0x4d: ADD R3, #0				//	if (root->right == NULL)
0xe5,  0x59, // 0x4e: BNE :insert_if_else		//	.
0x0e,  0x00, // 0x4f: PUSH R0					//	Save R0
0x0e,  0x10, // 0x50: PUSH R1					//	Save R1
0x0e,  0x20, // 0x51: PUSH R2					//	Save R2
0x0e,  0x10, // 0x52: PUSH R1					//	add_new_node(element);
0x10,  0x31, // 0x53: JSR :add_new_node_func	//	.
0xcf,  0x00, // 0x54: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x55: POP R2					//	Restore R2
0x4f,  0x00, // 0x56: POP R1					//	Restore R1
0x0f,  0x00, // 0x57: POP R0					// 	Restore R0
0xcc,  0x20, // 0x58: SMR R3, R2				//	root->right = next_node (return value)
0x11,  0x00, // 0x59: RTS
// :insert_if_else
0x0e,  0x10, // 0x5a: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x5b: LMR R2, R2				//	R2 = root->right
0x0e,  0x20, // 0x5c: PUSH R2					//	Push R2 (root->right)
0x10,  0x40, // 0x5d: JSR :insert_func		//	insert(root->right, element);
0x11,  0x00, // 0x5e: RTS
// :insert_else_if
0xe5,  0x60, // 0x5f: BNE :insert_else_if_if			// if (root->value == element) return;
0x11,  0x00, // 0x60: RTS
// :insert_else_if_if
0x83,  0x01, // 0x61: LDR R2, #1				//	R2 = 1
0x82,  0x86, // 0x62: ADD R2, R0, R2			//	R2 = &(root->left)
0xcb,  0x20, // 0x63: LMR R3, R2				// 	R3 = root->left
0xc6,  0x06, // 0x64: ADD R3, #0					//	if (root->left == NULL)
0xe5,  0x70, // 0x65: BNE :insert_else_if_else	//	.
0x0e,  0x00, // 0x66: PUSH R0					//	Save R0
0x0e,  0x10, // 0x67: PUSH R1					//	Save R1
0x0e,  0x20, // 0x68: PUSH R2					//	Save R2
0x0e,  0x10, // 0x69: PUSH R1					//	add_new_node(element);
0x10,  0x31, // 0x6a: JSR :add_new_node_func	//	.
0xcf,  0x00, // 0x6b: POP R3					//	R3 = next_node (return value)
0x8f,  0x00, // 0x6c: POP R2					//	Restore R2
0x4f,  0x00, // 0x6d: POP R1					//	Restore R1
0x0f,  0x00, // 0x6e: POP R0					// 	Restore R0
0xcc,  0x20, // 0x6f: SMR R3, R2				//	root->left = next_node (return value)
0x11,  0x00, // 0x70: RTS
// :insert_else_if_else
0x0e,  0x10, // 0x71: PUSH R1					//	Push R1 (element)
0x8b,  0x20, // 0x72: LMR R2, R2				//	R2 = root->left
0x0e,  0x20, // 0x73: PUSH R2					//	Push R2 (root->left)
0x10,  0x40, // 0x74: JSR :insert_func		//	insert(root->left, element);
0x11,  0x00, // 0x75: RTS

// :traverse_func
0x0f,  0x00, // 0x76: POP	R0					//	R0 = return address
0x4f,  0x00, // 0x77: POP R1					//	R1 = root (parameter variable)
0x0e,  0x00, // 0x78: PUSH R0					// 	Push return address
0x46,  0x07, // 0x79: SUB R1, #0				// 	if (R1 (root) == NULL)
0xe5,  0x7b, // 0x7a: BNE :traverse_func_core	//	.
0x11,  0x00, // 0x7b: RTS						//	return;
// :traverse_func_core
0x46,  0x16, // 0x7c: INC R1					//	R1 = &(root->left)
0x0b,  0x10, // 0x7d: LMR R0, R1				//	R0 = root->left
0x0e,  0x10, // 0x7e: PUSH R1					//	Save R1
0x0e,  0x00, // 0x7f: PUSH R0					//	traverse(root->left);
0x10,  0x75, // 0x80: JSR :traverse_func		//	.
0x4f,  0x00, // 0x81: POP R1					//	Restore R1
0x46,  0x17, // 0x82: DEC R1					//	R1 = &(root->value)
0x0b,  0x10, // 0x83: LMR R0, R1				//	R0 = root->value
0x28,  0x00, // 0x84: OUT R0, I				//	printf("%d", root->value);
0x0d,  0x20, // 0x85: OUT #0x20, A			//	printf(" ");
0x46,  0x26, // 0x86: ADD R1, #2				//	R1 = &(root->right)
0x0b,  0x10, // 0x87: LMR R0, R1				// 	R0 = root->right
0x0e,  0x00, // 0x88: PUSH R0					//	traverse(root->right);
0x10,  0x75, // 0x89: JSR :traverse_func		//	.
0x11,  0x00, // 0x8a: RTS

