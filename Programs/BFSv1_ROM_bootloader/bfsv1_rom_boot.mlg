//	BFSv1 ROM Boot Code
//	Assumes:
//		1.	A BFSv1 filesystem is in use and the ByteFrost disk file used on the
//			disk has its boot sector correctly set up with first mutablle code.

//	This BFSv1 ROM Boot Code does the following:
//	1.	Load the boot sector from disk into RAM (at 0x2000)
//		*	The boot sector in disk is 2 KB (2 KB * (4 pages / 1 KB) = 8 pages)
//		*	ByteFrost memory address space is as follows (64KB, 16-bit address):
//			+-------------------------------+
//			| MMIO (8 KB) (0xE000 - 0xFFFF) |	Pages 224 - 255
//			| (disk, cycle counter, RNG)    |
//			+-------------------------------+
//			| RAM (48 KB) (0x2000 - 0xDFFF) |	Pages 32 - 223
//			|                               |
//			|                               |
//			+-------------------------------+
//			| ROM (8 KB)  (0x0000 - 0x1FFF) |	Pages 0 - 31
//			| (this boot code)              |
//			+-------------------------------+
//		-> Load pages 32 - 39 with the boot code.
//	2.	Jump to the boot code.

//	Character constant definitions
//	NOTE: This is ugly, but the assembler does not yet support character-type
//		  immediates.
.define	1 NEW_LINE	 		0x10
.define 1 SPACE				0x20
.define 1 _1				0x31
.define	1 _A				0x41
.define	1 _B				0x42
.define	1 _C				0x43
.define	1 _D				0x44
.define	1 _E				0x45
.define	1 _F				0x46
.define	1 _G				0x47
.define	1 _H				0x48
.define	1 _I				0x49
.define	1 _J				0x4a
.define	1 _K				0x4b
.define	1 _L				0x4c
.define	1 _M				0x4d
.define	1 _N				0x4e
.define	1 _O				0x4f
.define	1 _P				0x50
.define	1 _Q				0x51
.define	1 _R				0x52
.define	1 _S				0x53
.define	1 _T				0x54
.define	1 _U				0x55
.define	1 _V				0x56
.define	1 _W				0x57
.define	1 _X				0x58
.define	1 _Y				0x59
.define	1 _Z				0x5a
.define 1 COLON				0x3a
.define 1 LEFT_PAR			0x28
.define	1 RIGHT_PAR			0x29
.define 1 COMMA				0x2c
.define 1 ASTERISK			0x2a
.define 1 _v				0x76
.define 1 _x				0x78
.define 1 EQUALS			0x3d

//	Address constant definitions

//	Disk MMIO base address (for sector read / write interface)
.define 2 sdcard			0xE000

//	1.	Print "BFSv1 ROM BOOT\n"
0x0d, 0x42,	// 0x0000: OUT _B, A
0x0d, 0x46,	// 0x0002: OUT _F, A
0x0d, 0x53,	// 0x0004: OUT _S, A
0x0d, 0x76,	// 0x0006: OUT _v, A
0x0d, 0x31,	// 0x0008: OUT _1, A
0x0d, 0x20,	// 0x000a: OUT SPACE, A
0x0d, 0x52,	// 0x000c: OUT _R, A
0x0d, 0x4f,	// 0x000e: OUT _O, A
0x0d, 0x4d,	// 0x0010: OUT _M, A
0x0d, 0x20,	// 0x0012: OUT SPACE, A
0x0d, 0x42,	// 0x0014: OUT _B, A
0x0d, 0x4f,	// 0x0016: OUT _O, A
0x0d, 0x4f,	// 0x0018: OUT _O, A
0x0d, 0x54,	// 0x001a: OUT _T, A
0x0d, 0x10,	// 0x001c: OUT NEW_LINE, A

//	2.	Copy first 8 pages from disk to pages 32 - 39 in RAM.
//	Set DP to point at the disk MMIO base address.
0x7b, 0xe0,	// 0x001e: LDA %DP, H, sdcard[1]
0x5b, 0x00,	// 0x0020: LDA %DP, L, sdcard[0]
0xfb, 0xe0,	// 0x0022: LDA %BP, H, sdcard[1]
0xdb, 0x00,	// 0x0024: LDA %BP, L, sdcard[0]
//	Disk MMIO interface is as follows:
//	Byte 0 (0xE000): Page (in ByteFrost address space)
//	Byte 1 (0xE001): Command and Sector High (3 lsbs)
//	Byte 2 (0xE002): Sector Low (8 bits)
//	Byte 3 (0xE003): Go (R/W to this address initiates disk operation)
//
//	Bytes 1 and 2 of the interface can be viewed as follows:
//	[Byte 1                           ][Byte 2]
//	15  14  13  12  11  10-8           7-0
//	R/W ?   ?   ?   ?   Sector ID High Sector ID Low
//
//	Note: This means that a Sector ID is 11-bits; given that each sector is the
//	same size as a ByteFrost page (256 bytes), this allows for a 512 KB disk.
//	Note that bits 11 - 14 aren't used, however - without hardware modification,
//	we can therefore expand the disk to 8 MB.
//
//	This allows for a simple read / write sector interface with the disk. The
//	actual copying of the sector to a page or vice-versa is done by the disk
//	interface and is a blocking operation (the ByteFrost CPU is stopped by the
//	disk interface! It stops fetching instructions until the disk operation is
//	complete).

.define	1 DISK_MMIO_PAGE_OFFSET			0
.define	1 DISK_MMIO_SECTOR_HI_OFFSET	1
.define 1 DISK_MMIO_SECTOR_LO_OFFSET	2
.define 1 DISK_MMIO_GO_OFFSET			3

0x03, 0x00,	// 0x0026: LDR R0, #0x00		//	R0: Sector
0x43, 0x20,	// 0x0028: LDR R1, #0x20		//  R1: Page
0x83, 0x00,	// 0x002a: LDR R2, #0x00		//  R2: Sector High + Command (Read)

:for_loop			//	{
0x37, 0x02,	// 0x002c: 	SDW R0, %BP, DISK_MMIO_SECTOR_LO_OFFSET	//		Sector to bring
0xb7, 0x01,	// 0x002e: 	SDW R2, %BP, DISK_MMIO_SECTOR_HI_OFFSET	//		Sector to bring
0x77, 0x00,	// 0x0030: 	SDW R1, %BP, DISK_MMIO_PAGE_OFFSET 		// 		Page to store
0x77, 0x03,	// 0x0032: 	SDW R1, %BP, DISK_MMIO_GO_OFFSET		// 		GO

0x0d, 0x50,	// 0x0034: 	OUT _P, A
0x0d, 0x47,	// 0x0036: 	OUT _G, A
0x0d, 0x20,	// 0x0038: 	OUT SPACE, A
0x28, 0x10,	// 0x003a: 	OUT R1, I
0x0d, 0x2c,	// 0x003c: 	OUT COMMA, A

0x0d, 0x53,	// 0x003e: 	OUT _S, A
0x0d, 0x43,	// 0x0040: 	OUT _C, A
0x0d, 0x20,	// 0x0042: 	OUT SPACE, A
0x28, 0x20,	// 0x0044: 	OUT R2, I
0x28, 0x00,	// 0x0046: 	OUT R0, I
0x0d, 0x10,	// 0x0048: 	OUT NEW_LINE, A
0x0d, 0x44,	// 0x004a: 	OUT _D, A
0x0d, 0x50,	// 0x004c: OUT _P, A
0x0d, 0x20,	// 0x004e: OUT SPACE, A
0xfa, 0x01,	// 0x0050: MAG R3, %DP, H
0x28, 0x30,	// 0x0052: OUT R3, I
0xda, 0x01,	// 0x0054: MAG R3, %DP, L
0x28, 0x30,	// 0x0056: OUT R3, I
0x0d, 0x2c,	// 0x0058: OUT COMMA, A
0x0d, 0x42,	// 0x005a: OUT _B, A
0x0d, 0x50,	// 0x005c: OUT _P, A
0x0d, 0x20,	// 0x005e: OUT SPACE, A
0xfa, 0x03,	// 0x0060: MAG R3, %BP, H
0x28, 0x30,	// 0x0062: OUT R3, I
0xda, 0x03,	// 0x0064: MAG R3, %BP, L
0x28, 0x30,	// 0x0066: OUT R3, I
0x0d, 0x10,	// 0x0068: OUT NEW_LINE, A

	
0x13, 0x77,	// 0x006a: 	TST R0, #0x07		//  Did we serve Sector 07 (Last Boot sector).
0x3b, 0x00,	// 0x006c: 	BEQ :after_for_loop	// Yes, we are done
0x65, 0x3c,	// 0x006e: (BEQ continued)
						// No, Copy the next sector
0x46, 0x16,	// 0x0070: 	INC R1			//  R1: Page++
0x06, 0x16,	// 0x0072: 	INC R0			//	R0: Sector++
0x3b, 0x00,	// 0x0074: 	JMP :for_loop	//	}
0x05, 0x16,	// 0x0076: (JMP continued)

:after_for_loop			//	Jump to boot sector code.
	
////////////////////////////////////////////////////
// CHECK BOOT ROM MEMORY LOADING


0x01, 0x00,	// 0x0078: BRK
	
0x3b, 0x10,	// 0x007a: JMP :__RAM_START__	//	Jump to RAM start (0x2000) - page 32.
0x05, 0x00,	// 0x007c: (JMP continued)
